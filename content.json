{"meta":{"title":"Vankood的博客","subtitle":"","description":"","author":"Vankood","url":"https://vankood.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-10-17T14:49:11.000Z","updated":"2020-10-17T14:49:12.008Z","comments":true,"path":"categories/index.html","permalink":"https://vankood.github.io/categories/index.html","excerpt":"","text":""},{"title":"picture","date":"2020-10-20T06:20:34.000Z","updated":"2020-10-20T06:22:32.051Z","comments":true,"path":"picture/index.html","permalink":"https://vankood.github.io/picture/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-14T16:00:00.000Z","updated":"2020-10-17T14:50:52.821Z","comments":true,"path":"tags/index.html","permalink":"https://vankood.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"杂七杂八","slug":"杂七杂八","date":"2020-10-26T12:03:16.494Z","updated":"2020-10-26T19:44:56.000Z","comments":true,"path":"2020/10/26/杂七杂八/","link":"","permalink":"https://vankood.github.io/2020/10/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 实现trim方法1234567891011121314151617public class vankood_test02 &#123; public static void main(String[] args) &#123; String s=&quot; dwf &quot;; int i=0; int j=s.length(); while(s.startsWith(&quot; &quot;,i))&#123; i++; &#125; while(s.endsWith(&quot; &quot;))&#123; j--; s=s.substring(0,j); &#125; System.out.println(j); String c=s.substring(i,j); System.out.println(c); &#125;&#125; #String类的replaceAll方法 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d+&quot;,&quot;,&quot;); System.out.println(string);结果：,hello,world, 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d&quot;,&quot;,&quot;); System.out.println(string); 结果:,,hello,world, 字符串指定位置反转123456789101112131415public class vankood_test04 &#123; public static void main(String[] args) &#123; int a=3; int b=6; StringBuffer sb=new StringBuffer(); String s=&quot;abcdefghijk&quot;; sb.append(s.substring(0,a)); for(int i=b;i&gt;a;i--)&#123; sb.append(s.substring(i-1,i)); &#125; sb.append(s.substring(b,s.length())); System.out.println(sb); &#125;&#125; 字符串出现次数获取一个字符串在另一个字符串中出现的次数。比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 1234567891011121314public class vankood_test05 &#123; public static void main(String[] args) &#123; String s=&quot;absdwabdwrrab&quot;; int i=0; int j=0; while(s.contains(&quot;ab&quot;))&#123; i++; s=s.substring(s.indexOf(&quot;ab&quot;)+1,s.length()); &#125; System.out.println(i); &#125;&#125; 字符串自然排序123456789101112131415import java.util.Arrays;public class vankood_test06 &#123; public static void main(String[] args) &#123; String s=&quot;abdgrgregr&quot;; char [] c=s.toCharArray(); Arrays.sort(c); System.out.println(c); char[] d=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; System.out.println(d); &#125;&#125; null长度1234567891011public class vankood_test002 &#123; public static void main(String[] args) &#123; String str&#x3D;null; StringBuffer sb&#x3D;new StringBuffer(); sb.append(str); System.out.println(sb.length()); System.out.println(sb); &#125;&#125; 结果：4 null","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"Hello World","slug":"异常处理_基础","date":"2020-10-26T09:33:19.046Z","updated":"2020-10-18T12:35:16.418Z","comments":true,"path":"2020/10/26/异常处理_基础/","link":"","permalink":"https://vankood.github.io/2020/10/26/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hamapi huasongyuanCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-26T09:33:14.891Z","updated":"2020-10-18T12:35:16.418Z","comments":true,"path":"2020/10/26/hello-world/","link":"","permalink":"https://vankood.github.io/2020/10/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hamapi huasongyuanCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"hashmap的底层实现原理","slug":"hashmap的底层实现原理","date":"2020-10-23T06:23:26.079Z","updated":"2020-10-26T13:34:57.454Z","comments":true,"path":"2020/10/23/hashmap的底层实现原理/","link":"","permalink":"https://vankood.github.io/2020/10/23/hashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"hashmap的底层实现原理基本概念程序：是为完成特定任务、某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程：是程序的一次执行过程。或者正在运行的一个程序。是一个动态过程：有他自身产生、存在、消亡的过程。线程：程序内部的一条执行路径。线程是程序执行的一条路径, 一个进程中可以包含多条线程。多线程并发执行可以提高程序的效率, 可以同时完成多项工作。 并行：多个cpu同时执行多个任务。比如多个人做不同的事情。并发：一个cpu（采用时间片）同时执行多个任务。比如：秒杀、多个人同时做一件事情。 守护线程用来服务于用户线程；不需要上层逻辑介入。当线程只剩下守护线程的时候,JVM就会退出；补充一点如果还有其他的任意一个用户线程还在，JVM就不会退出。 java垃圾回收就是一种典型的守护线程。 守护线程是用来服务用户线程的，通过在start()方法前调用 1thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。 用户线程：我们平常创建的普通线程。 线程的创建和使用方式一：继承于Thread类1234567891011121314151617181920212223242526272829303132/** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * &lt;p&gt; * 例子：遍历100以内的所有的偶数 * * @author vankood */public class Vankood_01 &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread m1=new MyThread(); //4. 通过此对象调用start() m1.start(); for(int i=0;i&lt;10000;i++)&#123; System.out.println(&quot;主线程&quot;); &#125; &#125;&#125;//1. 创建一个继承于Thread类的子类class MyThread extends Thread&#123; //2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 @Override public void run()&#123; System.out.println(&quot;分线程&quot;); &#125; &#125;&#125; 例子123456789101112131415161718192021222324252627282930313233343536373839/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * * * @author shkstart * @create 2019-02-13 下午 2:16 */public class vankood_02 &#123; public static void main(String[] args) &#123; Mythread1 m1=new Mythread1(); Mythread2 m2=new Mythread2(); m1.start(); m2.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class Mythread2 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125; 匿名子类方式创建线程1234567891011121314151617181920212223public class vankood_03 &#123; public static void main(String[] args) &#123; new Thread(&quot;线程一&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程二&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方式二：实现Runnable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * * @author shkstart * @create 2019-02-13 下午 4:34 */class Mythread implements Runnable&#123;// 1. 创建一个实现了Runnable接口的类 @Override public void run() &#123; // 2. 实现类去实现Runnable中的抽象方法：run() for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class vankood_04 &#123; public static void main(String[] args) &#123; Mythread mt=new Mythread(); //3. 创建实现类的对象 Thread t1=new Thread(mt); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.setName(&quot;线程一&quot;); Mythread mt2=new Mythread(); Thread t2=new Thread(mt2); t2.setName(&quot;线程二&quot;); t1.start(); //5. 通过Thread类的对象调用start() t2.start(); &#125;&#125; 两种方式的对比比较创建线程的两种方式。 开发中：优先选择：实现Runnable接口的方式** 原因： ** 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系： public class Thread implements Runnable Thread类实现了Runnable接口。 相同点： 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 线程的常用方法 测试Thread中的常用方法： start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程1Thread.currentThread().getName() getName():获取当前线程的名字 setName():设置当前线程的名字1HelloThread h1 &#x3D; new HelloThread(&quot;线程一&quot;); yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 1. MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class HelloThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123;// try &#123;// sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i % 20 == 0)&#123;// yield();// &#125; &#125; &#125; public HelloThread(String name)&#123; super(name); &#125;&#125;public class ThreadMethodTest &#123; public static void main(String[] args) &#123; HelloThread h1 = new HelloThread(&quot;Thread：1&quot;);// h1.setName(&quot;线程一&quot;); //设置分线程的优先级 h1.setPriority(Thread.MAX_PRIORITY); h1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i == 20)&#123;// try &#123;// h1.join();// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125; &#125;// System.out.println(h1.isAlive()); &#125;&#125; 线程的生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 *新建**：就是刚使用new方法，new出来的线程； *就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; *运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; *阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; *死亡**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;线程的同步在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 synchronized(同步监视器)&#123; //需要被同步的代码 &#125; ``` 说明： 1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。### 方式二：同步方法。如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 5.同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 #### 实现Runnable接口的线程同步（同步代码块） ```java class Window1 implements Runnable&#123; private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() &#123; // Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; class Dog&#123; &#125; 实现Runnable接口的线程同步（同步方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 *&#x2F;class Window2 extends Thread&#123; private static int ticket &#x3D; 100; private static Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; &#x2F;&#x2F;正确的&#x2F;&#x2F; synchronized (obj)&#123; synchronized (Window2.class)&#123;&#x2F;&#x2F;Class clazz &#x3D; Window2.class,Window2.class只会加载一次 &#x2F;&#x2F;错误的方式：this代表着t1,t2,t3三个对象&#x2F;&#x2F; synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 &#x3D; new Window2(); Window2 t2 &#x3D; new Window2(); Window2 t3 &#x3D; new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式三：Lock锁 — JDK5.0新增 1.synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.优先使用顺序： Lock 同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Window implements Runnable&#123; private int ticket = 10; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true);//true表示公平锁 @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 线程的通信notify和notifyallcom.atguigu.java2;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;** * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 * * 涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 * * 说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 * * @author shkstart * @create 2019-02-15 下午 4:21 *&#x2F;class Number implements Runnable&#123; private int number &#x3D; 1; private Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;&#x3D; 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; &#x2F;&#x2F;使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number &#x3D; new Number(); Thread t1 &#x3D; new Thread(number); Thread t2 &#x3D; new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; jdk5.0新增线程创建方式","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"IO流_基础","slug":"IO流_基础","date":"2020-10-22T09:08:48.799Z","updated":"2020-10-22T11:09:14.387Z","comments":true,"path":"2020/10/22/IO流_基础/","link":"","permalink":"https://vankood.github.io/2020/10/22/IO%E6%B5%81_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"IO流File类的使用","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"常用类_基础","slug":"常用类_基础","date":"2020-10-21T02:23:41.790Z","updated":"2020-10-27T12:23:02.981Z","comments":true,"path":"2020/10/21/常用类_基础/","link":"","permalink":"https://vankood.github.io/2020/10/21/%E5%B8%B8%E7%94%A8%E7%B1%BB_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"常用类String类String类：代表字符串，java程序中所有的字符串字面值（如“abc”）都作为此类的实例实现。String是一个final类，代表不可变序列源码： 1234567891011121314151617181920212223242526272829303132333435363738 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; &#x2F;** The value is used for character storage. *&#x2F; private final char value[]; &#x2F;** Cache the hash code for the string *&#x2F; private int hash; &#x2F;&#x2F; Default to 0 &#96;&#96;&#96; ![string.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;pgmIxRirzBkAYqT.png)String stri&#x3D;&quot;abc&quot;与 String str2&#x3D;new String(&quot;abc&quot;)的区别![string2.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;DQApK56luVkvZTF.png)![string3.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;T7Kna1UuDXqfko6.png)![String4.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;c3evpKsWG7hVaYO.png)**intern方法**将返回值放回到常量池中### 使用陷阱**String s1 &#x3D;&quot;a&quot;;** 说明:在字符串常量池中创建了一个字面量为&quot;a&quot;的字符串。 **s1 &#x3D;s1 +&quot;b&quot;** 说明:实际上原来的&quot;a&quot;字符串对象已经丢弃了,现在在堆空间中产生了一个字符串s1+&quot;b&quot; (也就是&quot;ab&quot;)。如果多次执行这些改变串内容的操作,会导致大量副本字符串对象存留在内存中,降低效率。如果这样的操作放到循环中,会极大影响程序的性能。 **String s2 &#x3D; &quot;ab&quot;**; 说明:直接在字符串常量池中创建一个字面量为&quot;ab&quot;的字符串。 **String s3 &#x3D;&quot;a&quot;+ &quot;b&quot;**; 说明: s3指向字符串常量池中已经创建的&quot;ab&quot;的字符串。 **String s4 &#x3D; s1.intern();** 说明:堆空间的s1对象在调用intern()之后,会将常量池中已经存在的&quot;ab&quot;字符串赋值给s4.### 常用方法![string5.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;ZJzDh7iweRuA3Kn.png)![string6.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;nOW7If543HlhPYU.png)![string8.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;iGQxJToUXhDC29g.png)### 面试题 public void test4()&#123; String s1 = &quot;javaEEhadoop&quot;; String s2 = &quot;javaEE&quot;; String s3 = s2 + &quot;hadoop&quot;; System.out.println(s1 == s3);//false final String s4 = &quot;javaEE&quot;;//s4:常量 String s5 = s4 + &quot;hadoop&quot;; System.out.println(s1 == s5);//true &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889### String跟byte[]之间的转换编码：String --&gt; byte[]:调用String的getBytes()解码：byte[] --&gt; String:调用String的构造器编码：字符串 --&gt;字节 (看得懂 ---&gt;看不懂的二进制数据)解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）### String类型的一些转换 &#96;&#96;&#96;java public class StringTest1 &#123; &#x2F;* String 与 byte[]之间的转换 编码：String --&gt; byte[]:调用String的getBytes() 解码：byte[] --&gt; String:调用String的构造器 编码：字符串 --&gt;字节 (看得懂 ---&gt;看不懂的二进制数据) 解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 *&#x2F; @Test public void test3() throws UnsupportedEncodingException &#123; String str1 &#x3D; &quot;abc123中国&quot;; byte[] bytes &#x3D; str1.getBytes();&#x2F;&#x2F;使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks &#x3D; str1.getBytes(&quot;gbk&quot;);&#x2F;&#x2F;使用gbk字符集进行编码。 System.out.println(Arrays.toString(gbks)); System.out.println(&quot;******************&quot;); String str2 &#x3D; new String(bytes);&#x2F;&#x2F;使用默认的字符集，进行解码。 System.out.println(str2); String str3 &#x3D; new String(gbks); System.out.println(str3);&#x2F;&#x2F;出现乱码。原因：编码集和解码集不一致！ String str4 &#x3D; new String(gbks, &quot;gbk&quot;); System.out.println(str4);&#x2F;&#x2F;没有出现乱码。原因：编码集和解码集一致！ &#125; &#x2F;* String 与 char[]之间的转换 String --&gt; char[]:调用String的toCharArray() char[] --&gt; String:调用String的构造器 *&#x2F; @Test public void test2()&#123; String str1 &#x3D; &quot;abc123&quot;; &#x2F;&#x2F;题目： a21cb3 char[] charArray &#x3D; str1.toCharArray(); for (int i &#x3D; 0; i &lt; charArray.length; i++) &#123; System.out.println(charArray[i]); &#125; char[] arr &#x3D; new char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; String str2 &#x3D; new String(arr); System.out.println(str2); &#125; &#x2F;* 复习： String 与基本数据类型、包装类之间的转换。 String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx) *&#x2F; @Test public void test1()&#123; String str1 &#x3D; &quot;123&quot;; &#x2F;&#x2F; int num &#x3D; (int)str1;&#x2F;&#x2F;错误的 int num &#x3D; Integer.parseInt(str1); String str2 &#x3D; String.valueOf(num);&#x2F;&#x2F;&quot;123&quot; String str3 &#x3D; num + &quot;&quot;; System.out.println(str1 &#x3D;&#x3D; str3); &#125; &#125; String matches StringBufferStringBuffer方法 String、StringBuffer、StringBuilder三者的异同 String:不可变的字符序列；底层使用char[]存储 StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 源码分析： 123456789101112131415String str = new String();//char[] value = new char[0]; String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。 System.out.println(sb1.length());// sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;; sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;; StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16]; //问题1. System.out.println(sb2.length());//3 //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) JDK8之前的时间API java.lang.System类System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 java.util.Date类表示特定的瞬间，精确到毫秒**getTime():**返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。**toString():**把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue,Wed, Thu, Fri, Sat)， zzz是时间标准。 1.两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象构造器二：创建指定毫秒数的Date对象 2.两个方法的使用 toString():显示当前的年、月、日、时、分、秒getTime():获取当前Date对象对应的毫秒数。（时间戳） 3.java.sql.Date对应着数据库中的日期类型的变量 如何实例化如何将java.util.Date对象转换为java.sql.Date对象 1234567891011121314151617181920212223242526272829303132333435 public void test2()&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Feb 16 16:35:31 GMT+08:00 2019 System.out.println(date1.getTime());//1550306204104 //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(155030620410L); System.out.println(date2.toString()); //创建java.sql.Date对象 java.sql.Date date3 = new java.sql.Date(35235325345L); System.out.println(date3);//1971-02-13 //如何将java.util.Date对象转换为java.sql.Date对象 //情况一：// Date date4 = new java.sql.Date(2343243242323L);// java.sql.Date date5 = (java.sql.Date) date4; //情况二： Date date6 = new Date(); java.sql.Date date7 = new java.sql.Date(date6.getTime()); &#125; //1.System类中的currentTimeMillis() @Test public void test1()&#123; long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); &#125;&#125; 日期和字符串相互转换1234567891011121314 //格式化：日期 ---&gt;字符串 Date date = new Date(); System.out.println(date); String format = sdf.format(date); System.out.println(format); //解析：格式化的逆过程，字符串 ---&gt; 日期 String str = &quot;19-12-18 上午11:43&quot;; Date date1 = sdf.parse(str); System.out.println(date1);``` //*************按照指定的方式格式化和解析：调用带参的构造器***************** // SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;); SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format1 = sdf1.format(date); System.out.println(format1);//2019-02-18 11:48:27 //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date date2 = sdf1.parse(&quot;2020-02-18 11:48:27&quot;); System.out.println(date2); 12345678910111213### 字符串&quot;2020-09-08&quot;转换为java.sql.Date &#96;&#96;&#96;java public void testExer() throws ParseException &#123; String birth &#x3D; &quot;2020-09-08&quot;; SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date &#x3D; sdf1.parse(birth); &#x2F;&#x2F; System.out.println(date); java.sql.Date birthDate &#x3D; new java.sql.Date(date.getTime()); System.out.println(birthDate); &#125; java.util.Calendar(日历)类Calendar类是一个抽象类，不能实例化 获取Calendar实例的方法 使用Calendar.getInstance()方法 调用它的子类GregorianCalendar的构造器。 1Calendar calendar &#x3D; Calendar.getInstance(); get操作1234&#x2F;&#x2F;get()int days &#x3D; calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); set操作12345//set() //calendar可变性 calendar.set(Calendar.DAY_OF_MONTH,22); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); add操作 123calendar.add(Calendar.DAY_OF_MONTH,-3);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days); getTime()操作123&#x2F;&#x2F;getTime():日历类---&gt; Date Date date &#x3D; calendar.getTime(); System.out.println(date); setTime()操作1234Date date1 &#x3D; new Date(); calendar.setTime(date1); days &#x3D; calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); JDK8中出现的新的类12345678910111213public void test1()&#123; &#x2F;&#x2F;now():获取当前的日期、时间、日期+时间 LocalDate localDate &#x3D; LocalDate.now(); LocalTime localTime &#x3D; LocalTime.now(); LocalDateTime localDateTime &#x3D; LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); &#x2F;&#x2F;of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); LocalDate中的get方法12345678910111213public void test1()&#123; &#x2F;&#x2F;now():获取当前的日期、时间、日期+时间 LocalDate localDate &#x3D; LocalDate.now(); LocalTime localTime &#x3D; LocalTime.now(); LocalDateTime localDateTime &#x3D; LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); &#x2F;&#x2F;of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); LocalDate中的with方法(设置相关属性) 12345678910111213141516&#x2F;&#x2F;withXxx():设置相关的属性 LocalDate localDate1 &#x3D; localDate.withDayOfMonth(22); System.out.println(localDate); System.out.println(localDate1); LocalDateTime localDateTime2 &#x3D; localDateTime.withHour(4); System.out.println(localDateTime); System.out.println(localDateTime2); &#x2F;&#x2F;不可变性 LocalDateTime localDateTime3 &#x3D; localDateTime.plusMonths(3); System.out.println(localDateTime); System.out.println(localDateTime3); LocalDateTime localDateTime4 &#x3D; localDateTime.minusDays(6); System.out.println(localDateTime); System.out.println(localDateTime4); Instant12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 @Test public void test2()&#123; &#x2F;&#x2F;now():获取本初子午线对应的标准时间 Instant instant &#x3D; Instant.now(); System.out.println(instant);&#x2F;&#x2F;2019-02-18T07:29:41.719Z &#x2F;&#x2F;添加时间的偏移量 OffsetDateTime offsetDateTime &#x3D; instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);&#x2F;&#x2F;2019-02-18T15:32:50.611+08:00 &#x2F;&#x2F;toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long milli &#x3D; instant.toEpochMilli(); System.out.println(milli); &#x2F;&#x2F;ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 &#x3D; Instant.ofEpochMilli(1550475314878L); System.out.println(instant1); &#125; &#x2F;* DateTimeFormatter:格式化或解析日期、时间 类似于SimpleDateFormat *&#x2F; @Test public void test3()&#123;&#x2F;&#x2F; 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter &#x3D; DateTimeFormatter.ISO_LOCAL_DATE_TIME; &#x2F;&#x2F;格式化:日期--&gt;字符串 LocalDateTime localDateTime &#x3D; LocalDateTime.now(); String str1 &#x3D; formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);&#x2F;&#x2F;2019-02-18T15:42:18.797 &#x2F;&#x2F;解析：字符串 --&gt;日期 TemporalAccessor parse &#x3D; formatter.parse(&quot;2019-02-18T15:42:18.797&quot;); System.out.println(parse);&#x2F;&#x2F; 方式二：&#x2F;&#x2F; 本地化相关的格式。如：ofLocalizedDateTime()&#x2F;&#x2F; FormatStyle.LONG &#x2F; FormatStyle.MEDIUM &#x2F; FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 &#x3D; DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); &#x2F;&#x2F;格式化 String str2 &#x3D; formatter1.format(localDateTime); System.out.println(str2);&#x2F;&#x2F;2019年2月18日 下午03时47分16秒&#x2F;&#x2F; 本地化相关的格式。如：ofLocalizedDate()&#x2F;&#x2F; FormatStyle.FULL &#x2F; FormatStyle.LONG &#x2F; FormatStyle.MEDIUM &#x2F; FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 &#x3D; DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); &#x2F;&#x2F;格式化 String str3 &#x3D; formatter2.format(LocalDate.now()); System.out.println(str3);&#x2F;&#x2F;2019-2-18&#x2F;&#x2F; 重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); &#x2F;&#x2F;格式化 String str4 &#x3D; formatter3.format(LocalDateTime.now()); System.out.println(str4);&#x2F;&#x2F;2019-02-18 03:52:09 &#x2F;&#x2F;解析 TemporalAccessor accessor &#x3D; formatter3.parse(&quot;2019-02-18 03:52:09&quot;); System.out.println(accessor); &#125;&#125; java比较器Java实现对象排序的方式有两种：  自然排序： java.lang.Comparable  定制排序： java.util.Comparator 方式一：自然排序： java.lang.ComparableComparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。 如果当前对象this大于形参对象obj， 则返回正整数，如果当前对象this小于形参对象obj， 则返回负整数，如果当前对象this等于形参对象obj， 则返回零。  实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。  对于类 C 的每一个e1和e2来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致。 建议（虽然不是必需的） 最好使自然排序与equals一致。","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"多线程_基础","slug":"多线程_基础","date":"2020-10-19T08:47:52.377Z","updated":"2020-10-26T13:34:57.453Z","comments":true,"path":"2020/10/19/多线程_基础/","link":"","permalink":"https://vankood.github.io/2020/10/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"多线程基本概念程序：是为完成特定任务、某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程：是程序的一次执行过程。或者正在运行的一个程序。是一个动态过程：有他自身产生、存在、消亡的过程。线程：程序内部的一条执行路径。线程是程序执行的一条路径, 一个进程中可以包含多条线程。多线程并发执行可以提高程序的效率, 可以同时完成多项工作。 并行：多个cpu同时执行多个任务。比如多个人做不同的事情。并发：一个cpu（采用时间片）同时执行多个任务。比如：秒杀、多个人同时做一件事情。 守护线程用来服务于用户线程；不需要上层逻辑介入。当线程只剩下守护线程的时候,JVM就会退出；补充一点如果还有其他的任意一个用户线程还在，JVM就不会退出。 java垃圾回收就是一种典型的守护线程。 守护线程是用来服务用户线程的，通过在start()方法前调用 1thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。 用户线程：我们平常创建的普通线程。 线程的创建和使用方式一：继承于Thread类1234567891011121314151617181920212223242526272829303132/** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * &lt;p&gt; * 例子：遍历100以内的所有的偶数 * * @author vankood */public class Vankood_01 &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread m1=new MyThread(); //4. 通过此对象调用start() m1.start(); for(int i=0;i&lt;10000;i++)&#123; System.out.println(&quot;主线程&quot;); &#125; &#125;&#125;//1. 创建一个继承于Thread类的子类class MyThread extends Thread&#123; //2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 @Override public void run()&#123; System.out.println(&quot;分线程&quot;); &#125; &#125;&#125; 例子123456789101112131415161718192021222324252627282930313233343536373839/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * * * @author shkstart * @create 2019-02-13 下午 2:16 */public class vankood_02 &#123; public static void main(String[] args) &#123; Mythread1 m1=new Mythread1(); Mythread2 m2=new Mythread2(); m1.start(); m2.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class Mythread2 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125; 匿名子类方式创建线程1234567891011121314151617181920212223public class vankood_03 &#123; public static void main(String[] args) &#123; new Thread(&quot;线程一&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程二&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方式二：实现Runnable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * * @author shkstart * @create 2019-02-13 下午 4:34 */class Mythread implements Runnable&#123;// 1. 创建一个实现了Runnable接口的类 @Override public void run() &#123; // 2. 实现类去实现Runnable中的抽象方法：run() for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class vankood_04 &#123; public static void main(String[] args) &#123; Mythread mt=new Mythread(); //3. 创建实现类的对象 Thread t1=new Thread(mt); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.setName(&quot;线程一&quot;); Mythread mt2=new Mythread(); Thread t2=new Thread(mt2); t2.setName(&quot;线程二&quot;); t1.start(); //5. 通过Thread类的对象调用start() t2.start(); &#125;&#125; 方式三：实现Callable接口方式四：使用线程池两种方式的对比比较创建线程的两种方式。 开发中：优先选择：实现Runnable接口的方式** 原因： ** 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系： public class Thread implements Runnable Thread类实现了Runnable接口。 相同点： 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 线程的常用方法 测试Thread中的常用方法： start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程1Thread.currentThread().getName() getName():获取当前线程的名字 setName():设置当前线程的名字1HelloThread h1 &#x3D; new HelloThread(&quot;线程一&quot;); yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 1. MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class HelloThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123;// try &#123;// sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i % 20 == 0)&#123;// yield();// &#125; &#125; &#125; public HelloThread(String name)&#123; super(name); &#125;&#125;public class ThreadMethodTest &#123; public static void main(String[] args) &#123; HelloThread h1 = new HelloThread(&quot;Thread：1&quot;);// h1.setName(&quot;线程一&quot;); //设置分线程的优先级 h1.setPriority(Thread.MAX_PRIORITY); h1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i == 20)&#123;// try &#123;// h1.join();// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125; &#125;// System.out.println(h1.isAlive()); &#125;&#125; 线程的生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 *新建**：就是刚使用new方法，new出来的线程； *就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; *运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; *阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; *死亡**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;线程的同步在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 synchronized(同步监视器)&#123; //需要被同步的代码 &#125; ``` 说明： 1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。### 方式二：同步方法。如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 5.同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 #### 实现Runnable接口的线程同步（同步代码块） ```java class Window1 implements Runnable&#123; private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() &#123; // Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; class Dog&#123; &#125; 实现Runnable接口的线程同步（同步方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 *&#x2F;class Window2 extends Thread&#123; private static int ticket &#x3D; 100; private static Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; &#x2F;&#x2F;正确的&#x2F;&#x2F; synchronized (obj)&#123; synchronized (Window2.class)&#123;&#x2F;&#x2F;Class clazz &#x3D; Window2.class,Window2.class只会加载一次 &#x2F;&#x2F;错误的方式：this代表着t1,t2,t3三个对象&#x2F;&#x2F; synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 &#x3D; new Window2(); Window2 t2 &#x3D; new Window2(); Window2 t3 &#x3D; new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式三：Lock锁 — JDK5.0新增 1.synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.优先使用顺序： Lock 同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Window implements Runnable&#123; private int ticket = 10; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true);//true表示公平锁 @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 线程的通信notify和notifyallcom.atguigu.java2;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;** * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 * * 涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 * * 说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 * * @author shkstart * @create 2019-02-15 下午 4:21 *&#x2F;class Number implements Runnable&#123; private int number &#x3D; 1; private Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;&#x3D; 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; &#x2F;&#x2F;使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number &#x3D; new Number(); Thread t1 &#x3D; new Thread(number); Thread t2 &#x3D; new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; notifyAlljdk5.0新增线程创建方式","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}