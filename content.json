{"meta":{"title":"Vankood的博客","subtitle":"","description":"","author":"Vankood","url":"https://vankood.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-10-17T14:49:11.000Z","updated":"2020-10-17T14:49:12.008Z","comments":true,"path":"categories/index.html","permalink":"https://vankood.github.io/categories/index.html","excerpt":"","text":""},{"title":"picture","date":"2020-10-20T06:20:34.000Z","updated":"2020-10-20T06:22:32.051Z","comments":true,"path":"picture/index.html","permalink":"https://vankood.github.io/picture/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-14T16:00:00.000Z","updated":"2020-10-17T14:50:52.821Z","comments":true,"path":"tags/index.html","permalink":"https://vankood.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程_基础","slug":"多线程_基础","date":"2020-10-19T08:47:52.377Z","updated":"2020-10-20T13:21:40.620Z","comments":true,"path":"2020/10/19/多线程_基础/","link":"","permalink":"https://vankood.github.io/2020/10/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"多线程基本概念程序：是为完成特定任务、某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程：是程序的一次执行过程。或者正在运行的一个程序。是一个动态过程：有他自身产生、存在、消亡的过程。线程：程序内部的一条执行路径。线程是程序执行的一条路径, 一个进程中可以包含多条线程。多线程并发执行可以提高程序的效率, 可以同时完成多项工作。 并行：多个cpu同时执行多个任务。比如多个人做不同的事情。并发：一个cpu（采用时间片）同时执行多个任务。比如：秒杀、多个人同时做一件事情。 守护线程用来服务于用户线程；不需要上层逻辑介入。当线程只剩下守护线程的时候,JVM就会退出；补充一点如果还有其他的任意一个用户线程还在，JVM就不会退出。 java垃圾回收就是一种典型的守护线程。 守护线程是用来服务用户线程的，通过在start()方法前调用 1thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。 用户线程：我们平常创建的普通线程。 线程的创建和使用方式一：继承于Thread类1234567891011121314151617181920212223242526272829303132/** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * &lt;p&gt; * 例子：遍历100以内的所有的偶数 * * @author vankood */public class Vankood_01 &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread m1=new MyThread(); //4. 通过此对象调用start() m1.start(); for(int i=0;i&lt;10000;i++)&#123; System.out.println(&quot;主线程&quot;); &#125; &#125;&#125;//1. 创建一个继承于Thread类的子类class MyThread extends Thread&#123; //2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 @Override public void run()&#123; System.out.println(&quot;分线程&quot;); &#125; &#125;&#125; 例子123456789101112131415161718192021222324252627282930313233343536373839/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * * * @author shkstart * @create 2019-02-13 下午 2:16 */public class vankood_02 &#123; public static void main(String[] args) &#123; Mythread1 m1=new Mythread1(); Mythread2 m2=new Mythread2(); m1.start(); m2.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class Mythread2 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125; 匿名子类方式创建线程1234567891011121314151617181920212223public class vankood_03 &#123; public static void main(String[] args) &#123; new Thread(&quot;线程一&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程二&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方式二：实现Runnable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * * @author shkstart * @create 2019-02-13 下午 4:34 */class Mythread implements Runnable&#123;// 1. 创建一个实现了Runnable接口的类 @Override public void run() &#123; // 2. 实现类去实现Runnable中的抽象方法：run() for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class vankood_04 &#123; public static void main(String[] args) &#123; Mythread mt=new Mythread(); //3. 创建实现类的对象 Thread t1=new Thread(mt); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.setName(&quot;线程一&quot;); Mythread mt2=new Mythread(); Thread t2=new Thread(mt2); t2.setName(&quot;线程二&quot;); t1.start(); //5. 通过Thread类的对象调用start() t2.start(); &#125;&#125; 两种方式的对比比较创建线程的两种方式。 开发中：优先选择：实现Runnable接口的方式** 原因： ** 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系： public class Thread implements Runnable Thread类实现了Runnable接口。 相同点： 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 线程的常用方法 测试Thread中的常用方法： start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程1Thread.currentThread().getName() getName():获取当前线程的名字 setName():设置当前线程的名字1HelloThread h1 &#x3D; new HelloThread(&quot;线程一&quot;); yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 1. MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class HelloThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123;// try &#123;// sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i % 20 == 0)&#123;// yield();// &#125; &#125; &#125; public HelloThread(String name)&#123; super(name); &#125;&#125;public class ThreadMethodTest &#123; public static void main(String[] args) &#123; HelloThread h1 = new HelloThread(&quot;Thread：1&quot;);// h1.setName(&quot;线程一&quot;); //设置分线程的优先级 h1.setPriority(Thread.MAX_PRIORITY); h1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i == 20)&#123;// try &#123;// h1.join();// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125; &#125;// System.out.println(h1.isAlive()); &#125;&#125; 线程的生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 *新建**：就是刚使用new方法，new出来的线程； *就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; *运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; *阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; *死亡**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;线程的同步在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 synchronized(同步监视器)&#123; //需要被同步的代码 &#125; ``` 说明： 1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。### 方式二：同步方法。如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 5.同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 #### 实现Runnable接口的线程同步（同步代码块） ```java class Window1 implements Runnable&#123; private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() &#123; // Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; class Dog&#123; &#125; 实现Runnable接口的线程同步（同步方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 *&#x2F;class Window2 extends Thread&#123; private static int ticket &#x3D; 100; private static Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; &#x2F;&#x2F;正确的&#x2F;&#x2F; synchronized (obj)&#123; synchronized (Window2.class)&#123;&#x2F;&#x2F;Class clazz &#x3D; Window2.class,Window2.class只会加载一次 &#x2F;&#x2F;错误的方式：this代表着t1,t2,t3三个对象&#x2F;&#x2F; synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 &#x3D; new Window2(); Window2 t2 &#x3D; new Window2(); Window2 t3 &#x3D; new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式三：Lock锁 — JDK5.0新增 1.synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.优先使用顺序： Lock 同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Window implements Runnable&#123; private int ticket = 10; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true);//true表示公平锁 @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 线程的通信jdk5.0新增线程创建方式","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}