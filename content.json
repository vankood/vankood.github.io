{"meta":{"title":"Vankood的博客","subtitle":"","description":"","author":"Vankood","url":"https://vankood.github.io","root":"/"},"pages":[{"title":"picture","date":"2020-10-20T06:20:34.000Z","updated":"2020-10-20T06:22:32.051Z","comments":true,"path":"picture/index.html","permalink":"https://vankood.github.io/picture/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-17T14:49:11.000Z","updated":"2020-10-17T14:49:12.008Z","comments":true,"path":"categories/index.html","permalink":"https://vankood.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-14T16:00:00.000Z","updated":"2020-10-17T14:50:52.821Z","comments":true,"path":"tags/index.html","permalink":"https://vankood.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"集合源码分析","date":"2020-11-20T02:37:53.158Z","updated":"2020-10-18T12:35:16.418Z","comments":true,"path":"2020/11/20/集合源码分析/","link":"","permalink":"https://vankood.github.io/2020/11/20/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hamapi huasongyuanCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"JavaScript","slug":"javaweb","date":"2020-11-17T12:37:28.947Z","updated":"2020-11-22T14:42:16.245Z","comments":true,"path":"2020/11/17/javaweb/","link":"","permalink":"https://vankood.github.io/2020/11/17/javaweb/","excerpt":"","text":"#javaweb JavaScriptJavaScript基础概念Javascript 语言诞生主要是完成页面的数据验证。 因此它运行在客户端， 需要运行浏览器来解析执行 JavaScript 代码。 JavaScript里面的特殊的值JavaScript里特殊的值：undefined: 未定义，所有js变量未赋于初始值的时候，默认值都undefined。null: 空值NaN: 全称是：NotaNumber。非数字。非数值。 关系比较等于： == 等于是简单的做字面值的比较全等于： === 除了做字面值的比较之外， 还会比较两个变量的数据类型 逻辑运算且运算： &amp;&amp;或运算： ||取反运算： ! /*&amp;&amp; 且运算。有两种情况：第一种： 当表达式全为真的时候。 返回最后一个表达式的值。第二种： 当表达式中， 有一个为假的时候。 返回第一个为假的表达式的值|| 或运算第一种情况： 当表达式全为假时， 返回最后一个表达式的值第二种情况： 只要有一个表达式为真。 就会把回第一个为真的表达式的值并且 &amp;&amp; 与运算 和 ||或运算 有短路。短路就是说，当这个&amp;&amp;或||运算有结果了之后。后面的表达式不再执行*/ &amp;&amp; 且运算。有两种情况：第一种： 当表达式全为真的时候。 返回最后一个表达式的值。第二种： 当表达式中， 有一个为假的时候。 返回第一个为假的表达式的值*/var a = “abc”;var b = true;var d = false;var c = null;// alert( a &amp;&amp; b );//true// alert( b &amp;&amp; a );//true// alert( a &amp;&amp; d ); // false// alert( a &amp;&amp; c ); // null/* || 或运算第一种情况： 当表达式全为假时， 返回最后一个表达式的值第二种情况： 只要有一个表达式为真。 就会把回第一个为真的表达式的值*/// alert( d || c ); // null// alert( c|| d ); //false// alert( a || c ); //abc// alert( b || c ); //true js中的事件onload 加载完成事件： 页面加载完成之后， 常用于做页面 js 代码初始化操作onclick 单击事件： 常用于按钮的点击响应操作。onblur 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作onsubmit 表单提交事件： 常用于表单提交前， 验证所有表单项是否合法。 Dom模型DOM 全称是Document ObjectModel文档对象模型就是把文档中的标签。属性文本转换成对象来管理。 用户名的校验方法一1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;xiaoyan&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;* * 需求：当用户点击了较验按钮，要获取输出框中的内容。然后验证其是否合法。&lt;br&#x2F;&gt; * 验证的规则是：必须由字母，数字。下划线组成。并且长度是5到12位。 * *&#x2F; function onclickFun()&#123; &#x2F;&#x2F; 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。 var usernameObh&#x3D;document.getElementById(&quot;username&quot;); &#x2F;&#x2F; [object HTMLInputElement] 它就是dom对象 var userText&#x3D;usernameObh.value; var patt &#x3D; &#x2F;^\\w&#123;5,12&#125;$&#x2F;; &#x2F;* * test()方法用于测试某个字符串，是不是匹配我的规则 ， * 匹配就返回true。不匹配就返回false. * *&#x2F; if(patt.test(userText))&#123; alert(&quot;合法&quot;); &#125;else &#123; alert(&quot;不合法&quot;); &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt; &lt;button onclick&#x3D;&quot;onclickFun()&quot;&gt;校验&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 方法二12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;用户名校验&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; function oneClickFun()&#123; &#x2F;&#x2F; 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。 var usernameobj&#x3D; document.getElementById(&quot;username01&quot;); var userText&#x3D;usernameobj.value; &#x2F;&#x2F;正则表达式 var usernameHtm&#x3D;document.getElementById(&quot;usernameSpan&quot;); var patt &#x3D; &#x2F;^\\w&#123;5,12&#125;$&#x2F;; if(patt.test(userText))&#123; usernameHtm.innerHTML &#x3D; &quot;&lt;img src&#x3D;\\&quot;right.png\\&quot; width&#x3D;\\&quot;18\\&quot; height&#x3D;\\&quot;18\\&quot;&gt; 用户名输入合法&quot;; alert(&quot;用户名输入合法&quot;); &#125;else &#123; usernameHtm.innerHTML &#x3D; &quot;&lt;img src&#x3D;\\&quot;wrong.png\\&quot; width&#x3D;\\&quot;18\\&quot; height&#x3D;\\&quot;18\\&quot;&gt;&quot;; alert(&quot;用户名输入不合法&quot;); &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username01&quot;&gt; &lt;span id&#x3D;&quot;usernameSpan&quot; style&#x3D;&quot;color: red;&quot;&gt; &lt;&#x2F;span&gt; &lt;br&gt; &lt;button onclick&#x3D;&quot;oneClickFun()&quot;&gt;校验&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; JSPjsp的全换是java server pages。 Java的服务器页面。 jsp的主要作用是代替Servlet程序回传html页面的数据。 因为Servlet程序回传html页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。 JSP的本质JSP页面本质上是一个Servlet程序 当我们第一次访问jsp页面的时候。 Tomcat服务器会帮我们把jsp页面翻译成为一个java源文件。 并且对它进行编译成为.class字节码程序。 JSP的三种语法JSP的头部page指令&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; 1.language属性表示jsp翻译后是什么语言文件。暂时只支持java。2. contentType属性表示jsp返回的数据类型是什么。也是源码中response.setContentType()参数值。3.pageEncoding属性表示当前jsp页面文件本身的字符集。4.import属性跟java源代码中一样。用于导包,导类。5.autoFlush属性设置当out输出流缓冲区满了之后，是否自动刷新冲级区。默认值是true。6.buffer属性设置out缓冲区的大小。默认是8kb。7.errorPage属性设置当jsp页面运行时出错,自动跳转去的错误页面路径。8.isErrorPage属性设置当前jsp页面是否是错误信息页面。默认是false。如果是true可以获取异常信息。9.session属性设置访问当前jsp页面，是否会创建HttpSession对象。默认是true。10.extends属性设置jsp翻译出来的java类默认继承谁。 JSP的常用脚本声明脚本声明脚本的格式是： &lt;%! 声明 java 代码 %&gt; 1、 声明类属性2、 声明 static 静态代码块3、 声明类方法4、 声明内部类 123456789101112131415161718192021222324252627&lt;%--1、 声明类属性--%&gt;&lt;%!private Integer id;private String name;private static Map&lt;String,Object&gt; map;%&gt; &lt;%--2、 声明 static 静态代码块--%&gt;&lt;%!static &#123; map &#x3D; new HashMap&lt;String,Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;);&#125;%&gt;&lt;%--3、 声明类方法--%&gt;&lt;%!public int abc()&#123; return 12;&#125;%&gt;&lt;%--4、 声明内部类--%&gt;&lt;%!public static class A &#123; private Integer id &#x3D; 12; private String abc &#x3D; &quot;abc&quot;;&#125;%&gt; 表达式脚本表达式脚本的格式是： &lt;%=表达式%&gt;表达式脚本的作用是： 的 jsp 页面上输出数据。表达式脚本的特点：1、所有的表达式脚本都会被翻译到_jspService()方法中2、表达式脚本都会被翻译成为out.print()输出到页面上3、由于表达式脚本翻译的内容都在_jspService()方法中,所以_jspService()方法中的对象都可以直接使用。4、表达式脚本中的表达式不能以分号结束 输出整型 输出浮点型 输出字符串 输出对象 12345&lt;%&#x3D;12 %&gt; &lt;br&gt; &lt;%&#x3D;12.12 %&gt; &lt;br&gt; &lt;%&#x3D;&quot;我是字符串&quot; %&gt; &lt;br&gt; &lt;%&#x3D;map%&gt; &lt;br&gt; &lt;%&#x3D;request.getParameter(&quot;username&quot;)%&gt; 代码脚本代码脚本的格式是： 12345678910111213141516171819202122 java 语句 %&gt;&#96;&#96;&#96; 代码脚本的作用是：可以在jsp页面中，编写我们自己需要的功能（写的是java语句）。代码脚本的特点是： 1、 代码脚本翻译之后都在&#96;&#96;&#96;_jspService&#96;&#96;&#96;方法中。 2、 代码脚本由于翻译到&#96;&#96;&#96;_jspService()&#96;&#96;&#96;方法中，所以在&#96;&#96;&#96;_jspService()&#96;&#96;&#96;方法中的现有对象都可以直接使用。 3、 还可以由多个代码脚本块组合完成一个完整的java语句。 4、 代码脚本还可以和表达式脚本一起组合使用，在jsp页面上输出数据。 ### JSP九大内置对象jsp中的内置对象，是指Tomcat在翻译jsp页面成为Servlet源代码后，内部提供的九大对象，叫内置对象。![1605953612_1_.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;21&#x2F;d7pKekfo6lZcC92.png)### JSP四大域对象pageContext (PageContextImpl 类) 当前 jsp 页面范围内有效 request (HttpServletRequest 类)、 一次请求内有效 session (HttpSession 类)、 一个会话范围内有效（打开浏览器访问服务器， 直到关闭浏览器） application (ServletContext 类) 整个 web 工程范围内都有效（只要 web 工程不停止， 数据都在） &lt;%– Created by IntelliJ IDEA. User: vankood Date: 2020/11/21 Time: 20:07 To change this template use File | Settings | File Templates. –%&gt; &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; scope.jsp页面 &lt;/head&gt; &lt;body&gt; &lt;% // 往四个域中都分别保存了数据 pageContext.setAttribute(&quot;key&quot;, &quot;pageContext&quot;); request.setAttribute(&quot;key&quot;, &quot;request&quot;); session.setAttribute(&quot;key&quot;, &quot;session&quot;); application.setAttribute(&quot;key&quot;, &quot;application&quot;); %&gt; pageContext域是否有值：&lt;%=pageContext.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; request域是否有值：&lt;%=request.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; session域是否有值：&lt;%=session.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; application域是否有值：&lt;%=application.getAttribute(&quot;key&quot;)%&gt; &lt;br&gt; &lt;% request.getRequestDispatcher(&quot;/scope2.jsp&quot;).forward(request,response); %&gt; &lt;/body&gt; &lt;/html&gt; 1234567891011域对象是可以像 Map 一样存取数据的对象。 四个域对象功能一样。 不同的是它们对数据的存取范围。 虽然四个域对象都可以存取数据。 在使用上它们是有优先顺序的。 四个域在使用的时候， 优先顺序分别是， 他们从小到大的范围的顺序。 pageContext &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; request &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; session &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt; application ### out 输出和 response.getWriter 输出的区别![图片.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;21&#x2F;bqsFJvtpSyfBY9x.png) &lt;%-- Created by IntelliJ IDEA. User: vankood Date: 2020/11/21 Time: 20:55 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.write(&quot;write输出1&lt;br/&gt;&quot;); out.print(&quot;print输出1&lt;br/&gt;&quot;); out.flush(); out.print(&quot;print输出2&lt;br/&gt;&quot;); out.write(&quot;write输出2&lt;br/&gt;&quot;); response.getWriter().write(&quot;response输出1 &lt;br&gt;&quot;); response.getWriter().write(&quot;response输出2 &lt;br&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 12345678![图片.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;21&#x2F;LV32rzQKRkG6ITZ.png)### JSP的常用标签#### jsp静态包含 &lt;%-- &lt;%@ include file=&quot;&quot;%&gt; 就是静态包含 file 属性指定你要包含的 jsp 页面的路径 地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录 静态包含的特点： 1、 静态包含不会翻译被包含的 jsp 页面。 2、 静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出。--%&gt; &lt;%@ include file=&quot;/include/footer.jsp&quot;%&gt; 123#### jsp动态包含 &lt;%-- &lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; 这是动态包含 page 属性是指定你要包含的 jsp 页面的路径 动态包含也可以像静态包含一样。 把被包含的内容执行输出到包含位置 动态包含的特点： 1、 动态包含会把包含的 jsp 页面也翻译成为 java 代码 2、 动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。 JspRuntimeLibrary.include(request, response, &quot;/include/footer.jsp&quot;, out, false); 3、 动态包含， 还可以传递参数 --%&gt; &lt;jsp:include page=&quot;/include/footer.jsp&quot;&gt; &lt;jsp:param name=&quot;username&quot; value=&quot;bbj&quot;/&gt; &lt;jsp:param name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/jsp:include&gt; 12##### 动态包含代码 &lt;%-- Created by IntelliJ IDEA. User: vankood Date: 2020/11/21 Time: 21:08 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;静态包含和动态包含&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 头部信息1&lt;br&gt; 主题信息&lt;br&gt; &lt;jsp:include page=&quot;footer.jsp&quot;&gt; &lt;jsp:param name=&quot;username&quot; value=&quot;bbj&quot;/&gt; &lt;jsp:param name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/jsp:include&gt; &lt;/body&gt; &lt;/html&gt; 123footer 代码 &lt;%-- Created by IntelliJ IDEA. User: vankood Date: 2020/11/21 Time: 21:09 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;脚页信息&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 页脚信息&lt;br&gt; 密码信息:&lt;%=request.getParameter(&quot;password&quot;)%&gt; &lt;/body&gt; &lt;/html&gt; 12#### 标签转发 &lt;%-- &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 是请求转发标签， 它的功能就是请求转发 page 属性设置请求转发的路径 --%&gt; &lt;jsp:forward page=&quot;/scope2.jsp&quot;&gt;&lt;/jsp:forward&gt; 1234567891011121314151617## EL表达式EL表达式的全称是：Expression Language。是表达式语言。 EL表达式的什么作用： EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 因为EL表达式在输出数据的时候，要比jsp的表达式脚本要简洁很多 ### EL 表达式搜索域数据的顺序EL表达式主要是在jsp页面中输出数据。 主要是输出域对象中的数据。当四个域中都有相同的key的数据的时候，EL表达式会按照四个域的从小到大的顺序去进行搜索， 找到就输出。 ### EL表达式输出属性 &lt;%@ page import=&quot;pojo.Person&quot; %&gt; &lt;%@ page import=&quot;java.util.List&quot; %&gt; &lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt; &lt;%@ page import=&quot;java.util.Map&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%-- Created by IntelliJ IDEA. User: vankood Date: 2020/11/22 Time: 21:27 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Person p1=new Person(); p1.setName(&quot;vankood&quot;); p1.setPhones(new String[]&#123;&quot;18610541354&quot;,&quot;18688886666&quot;,&quot;18699998888&quot;&#125;); List&lt;String&gt; cities = new ArrayList&lt;&gt;(); cities.add(&quot;北京&quot;); cities.add(&quot;上海&quot;); cities.add(&quot;深圳&quot;); p1.setCities(cities); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key1&quot;,&quot;value1&quot;); map.put(&quot;key2&quot;,&quot;value2&quot;); map.put(&quot;key3&quot;,&quot;value3&quot;); p1.setMap(map); pageContext.setAttribute(&quot;bala&quot;, p1); %&gt; 输出Person：$&#123; bala &#125;&lt;br/&gt; 输出Person的name数组属性值：$&#123;bala.name&#125;&lt;br/&gt; 输出Person的cities集合中的元素值：$&#123;bala.cities&#125;&lt;br/&gt; 输出Person的List集合中个别元素值： $&#123;bala.cities[2]&#125;&lt;br/&gt; 输出Person的Map集合:$&#123;bala.map&#125;&lt;br/&gt; 输出Person的Map集合中某个key的值: $&#123;bala.map.key2&#125;&lt;br&gt; 输出Person的age属性： $&#123;bala.age&#125;&lt;br&gt; &lt;/body&gt; &lt;/html&gt; 12345678910111213141516171819202122232425![图片.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;22&#x2F;teC45APJfUXoSTN.png)### 关系表达式![1606055368_1_.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;22&#x2F;5CDeL3NHwJhzRQm.png)### 逻辑运算![1606055385_1_.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;22&#x2F;Dviy2nkG64BNsZj.png)### 算数运算![1606055409_1_.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;22&#x2F;cdKUbhvnu93qiBw.png)### 判断是否为空empty 运算可以判断一个数据是否为空， 如果为空， 则输出 true,不为空输出 false。以下几种情况为空： 1、 值为 null 值的时候， 为空 2、 值为空串的时候， 为空 3、 值是 Object 类型数组， 长度为零的时候 4、 list 集合， 元素个数为零 5、 map 集合， 元素个数为零 &lt;body&gt; &lt;% // 1、值为null值的时候，为空 request.setAttribute(&quot;emptyNull&quot;, null); // 2、值为空串的时候，为空 request.setAttribute(&quot;emptyStr&quot;, &quot;&quot;); // 3、值是Object类型数组，长度为零的时候 request.setAttribute(&quot;emptyArr&quot;, new Object[]&#123;&#125;); // 4、list集合，元素个数为零 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // list.add(&quot;abc&quot;); request.setAttribute(&quot;emptyList&quot;, list); // 5、map集合，元素个数为零 Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); // map.put(&quot;key1&quot;, &quot;value1&quot;); request.setAttribute(&quot;emptyMap&quot;, map); %&gt; $&#123; empty emptyNull &#125; &lt;br/&gt; $&#123; empty emptyStr &#125; &lt;br/&gt; $&#123; empty emptyArr &#125; &lt;br/&gt; $&#123; empty emptyList &#125; &lt;br/&gt; $&#123; empty emptyMap &#125; &lt;br/&gt; &lt;/body&gt; ```","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://vankood.github.io/categories/JavaWeb/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"javaWeb","slug":"javaWeb","permalink":"https://vankood.github.io/tags/javaWeb/"}]},{"title":"杂七杂八","slug":"常见的十大基本算法","date":"2020-11-16T11:52:33.513Z","updated":"2020-11-17T12:12:06.856Z","comments":true,"path":"2020/11/16/常见的十大基本算法/","link":"","permalink":"https://vankood.github.io/2020/11/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%81%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 数据结构总结的一些基本算法二分查找(非递归)基本思想 代码1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Scanner;public class 二分查找 &#123; public static void main(String[] args) &#123; int[] arr=&#123;11,22,33,44,55,66,77,88,99,100&#125;; Scanner sc=new Scanner(System.in); while (sc.hasNext()) &#123; int target=sc.nextInt(); int s= binarySearch(arr, target); System.out.println(s); &#125; &#125; //二分查找的非递归实现 /** * * @param arr 待查找的数组, arr是升序排序 * @param target 需要查找的数 * @return 返回对应下标，-1表示没有找到 */ public static int binarySearch(int[] arr,int target)&#123; int left=0; int right=arr.length-1; int n=0; while(left&lt;=right) &#123; int mid=(left+right)/2; if (target == arr[mid]) &#123; n++; return n; &#125; else if (arr[mid] &lt; target) &#123; left = mid + 1; n++; &#125;else &#123; right=mid-1; n++; &#125; &#125; return -1; &#125;&#125; 分治算法介绍 基本步骤 汉诺塔问题123456789101112131415161718192021222324252627282930313233public class 汉诺塔 &#123; static int count = 0; public static void main(String[] args) &#123; hannuota(3,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;); //汉诺塔的移动的方法 //使用分治算法 System.out.println(&quot;共执行了&quot;+count+&quot;次&quot;); &#125; public static void hannuota(int num,char a,char b,char c) &#123; //如果只有一个盘子 if (num == 1) &#123; System.out.println(&quot;第1个盘从&quot; + a + &quot;到&quot; + c+&quot; &quot;+ (++count)+&quot;次&quot;); &#125; else &#123; //如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘 //1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c hannuota(num - 1, a, c, b); //2. 把最下边的盘 A-&gt;C System.out.println(&quot;第&quot; + num + &quot;个盘从&quot; + a + &quot;到&quot; + c+&quot; &quot;+(++count)+&quot;次&quot;); //3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔 hannuota(num - 1, b, a, c); &#125; &#125;&#125; 动态规划算法背包问题 字符串匹配暴力匹配1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ViolenceMatch &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //测试暴力匹配算法 String str1 = &quot;abddfda&quot;; String str2 = &quot;fa&quot;; int index = violenceMatch(str1, str2); System.out.println(&quot;index=&quot; + index); &#125; // 暴力匹配算法实现 public static int violenceMatch(String str1, String str2) &#123; char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0; // i索引指向s1 int j = 0; // j索引指向s2 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;// 保证匹配时，不越界 if(s1[i] == s2[j]) &#123;//匹配ok i++; j++; &#125; else &#123; //没有匹配成功 //如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。 i = i - (j - 1); j = 0; &#125; &#125; //判断是否匹配成功 if(j == s2Len) &#123; return i - j; &#125; else &#123; return -1; &#125; &#125;&#125; kmp算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.Arrays;public class KMPAlgorithm &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; TODO Auto-generated method stub String str1 &#x3D; &quot;BBC ABCDAB ABCDABCDABDE&quot;; String str2 &#x3D; &quot;ABCDABD&quot;; &#x2F;&#x2F;String str2 &#x3D; &quot;BBC&quot;; int[] next &#x3D; kmpNext(&quot;ABCDABD&quot;); &#x2F;&#x2F;[0, 1, 2, 0] System.out.println(&quot;next&#x3D;&quot; + Arrays.toString(next)); int index &#x3D; kmpSearch(str1, str2, next); System.out.println(&quot;index&#x3D;&quot; + index); &#x2F;&#x2F; 15了 &#125; &#x2F;&#x2F;写出我们的kmp搜索算法 &#x2F;** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置 *&#x2F; public static int kmpSearch(String str1, String str2, int[] next) &#123; &#x2F;&#x2F;遍历 for(int i &#x3D; 0, j &#x3D; 0; i &lt; str1.length(); i++) &#123; &#x2F;&#x2F;需要处理 str1.charAt(i) ！&#x3D; str2.charAt(j), 去调整j的大小 &#x2F;&#x2F;KMP算法核心点, 可以验证... while( j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j)) &#123; j &#x3D; next[j-1]; &#125; if(str1.charAt(i) &#x3D;&#x3D; str2.charAt(j)) &#123; j++; &#125; if(j &#x3D;&#x3D; str2.length()) &#123;&#x2F;&#x2F;找到了 &#x2F;&#x2F; j &#x3D; 3 i return i - j + 1; &#125; &#125; return -1; &#125; &#x2F;&#x2F;获取到一个字符串(子串) 的部分匹配值表 public static int[] kmpNext(String dest) &#123; &#x2F;&#x2F;创建一个next 数组保存部分匹配值 int[] next &#x3D; new int[dest.length()]; next[0] &#x3D; 0; &#x2F;&#x2F;如果字符串是长度为1 部分匹配值就是0 for(int i &#x3D; 1, j &#x3D; 0; i &lt; dest.length(); i++) &#123; &#x2F;&#x2F;当dest.charAt(i) !&#x3D; dest.charAt(j) ，我们需要从next[j-1]获取新的j &#x2F;&#x2F;直到我们发现 有 dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)成立才退出 &#x2F;&#x2F;这时kmp算法的核心点 while(j &gt; 0 &amp;&amp; dest.charAt(i) !&#x3D; dest.charAt(j)) &#123; j &#x3D; next[j-1]; &#125; &#x2F;&#x2F;当dest.charAt(i) &#x3D;&#x3D; dest.charAt(j) 满足时，部分匹配值就是+1 if(dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)) &#123; j++; &#125; next[i] &#x3D; j; &#125; return next; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://vankood.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://vankood.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://vankood.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"正则表达式","slug":"jQuery","date":"2020-11-13T11:56:59.431Z","updated":"2020-11-16T14:36:52.367Z","comments":true,"path":"2020/11/13/jQuery/","link":"","permalink":"https://vankood.github.io/2020/11/13/jQuery/","excerpt":"","text":"jQuery基本选择器12345#ID 选择器： 根据 id 查找标签对象 .class 选择器： 根据 class 查找标签对象 element 选择器： 根据标签名查找标签对象 * 选择器： 表示任意的， 所有的元素 selector1， selector2 组合选择器： 合并选择器 1， 选择器 2 的结果并返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;选择器&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;&#x2F;style&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function () &#123; &#x2F;&#x2F;1.选择 id 为 one 的元素 &quot;background-color&quot;,&quot;#bbffaa&quot; $(&quot;#btn1&quot;).click(function () &#123; $(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;2.选择 class 为 mini 的所有元素 $(&quot;#btn2&quot;).click(function () &#123; $(&quot;.mini&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;3.选择 元素名是 div 的所有元素 $(&quot;#btn3&quot;).click(function () &#123; $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;4.选择所有的元素 $(&quot;#btn4&quot;).click(function () &#123; $(&quot;*&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;5.选择所有的 span 元素和id为two的元素 $(&quot;#btn5&quot;).click(function () &#123; $(&quot;span,#two&quot;).css(&quot;background-color&quot;,&quot;#bbffaa&quot;); &#125;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 id 为 one 的元素&quot; id&#x3D;&quot;btn1&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 class 为 mini 的所有元素&quot; id&#x3D;&quot;btn2&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 元素名是 div 的所有元素&quot; id&#x3D;&quot;btn3&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 所有的元素&quot; id&#x3D;&quot;btn4&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 所有的 span 元素和id为two的元素&quot; id&#x3D;&quot;btn5&quot; &#x2F;&gt; &lt;br&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;two&quot; title&#x3D;&quot;test&quot;&gt; id为two，class为one，title为test的div &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;other&quot;&gt;class为mini,title为other&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;test&quot;&gt;class为mini,title为test&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;tesst&quot;&gt;class为mini,title为tesst&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;display:none;&quot; class&#x3D;&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;&#x2F;div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type&#x3D;&quot;hidden&quot; size&#x3D;&quot;8&quot;&gt; &lt;&#x2F;div&gt; &lt;span class&#x3D;&quot;one&quot; id&#x3D;&quot;span&quot;&gt;^^span元素^^&lt;&#x2F;span&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 层级选择器ancestor descendant 后代选择器 ： 在给定的祖先元素下匹配所有的后代元素parent &gt; child 子元素选择器： 在给定的父元素下匹配所有的子元素prev + next 相邻元素选择器： 匹配所有紧接在 prev 元素后的 next 元素prev ~ sibings 之后的兄弟元素选择器： 匹配 prev 元素之后的所有 siblings 元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;&#x2F;style&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;script&#x2F;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(document).ready(function()&#123; &#x2F;&#x2F;1.选择 body 内的所有 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;body div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;2.在 body 内, 选择div子元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;body &gt; div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;3.选择 id 为 one 的下一个 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#one+div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;4.选择 id 为 two 的元素后面的所有 div 兄弟元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#two~div&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;!-- &lt;div&gt; &lt;h1&gt;层级选择器:根据元素的层级关系选择元素&lt;&#x2F;h1&gt; ancestor descendant ： parent &gt; child ： prev + next ： prev ~ siblings ： &lt;&#x2F;div&gt; --&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 body 内的所有 div 元素&quot; id&#x3D;&quot;btn1&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;在 body 内, 选择div子元素&quot; id&#x3D;&quot;btn2&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 id 为 one 的下一个 div 元素&quot; id&#x3D;&quot;btn3&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择 id 为 two 的元素后面的所有 div 兄弟元素&quot; id&#x3D;&quot;btn4&quot; &#x2F;&gt; &lt;br&gt;&lt;br&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;two&quot; title&#x3D;&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;other&quot;&gt;class为mini,title为other&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;test&quot;&gt;class为mini,title为test&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;tesst&quot;&gt;class为mini,title为tesst&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;display:none;&quot; class&#x3D;&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;&#x2F;div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type&#x3D;&quot;hidden&quot; size&#x3D;&quot;8&quot;&gt; &lt;&#x2F;div&gt; &lt;span id&#x3D;&quot;span&quot;&gt;^^span元素^^&lt;&#x2F;span&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 基本过滤选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;Untitled Document&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;&#x2F;style&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;script&#x2F;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(document).ready(function()&#123; function anmateIt()&#123; $(&quot;#mover&quot;).slideToggle(&quot;slow&quot;, anmateIt); &#125; anmateIt(); &#125;); $(document).ready(function()&#123; &#x2F;&#x2F;1.选择第一个 div 元素 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;div:first&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;2.选择最后一个 div 元素 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;div:last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;3.选择class不为 one 的所有 div 元素 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;div:not(.one)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;4.选择索引值为偶数的 div 元素 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;div:even&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;5.选择索引值为奇数的 div 元素 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;div:odd&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;6.选择索引值为大于 3 的 div 元素 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;div:gt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;7.选择索引值为等于 3 的 div 元素 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;div:eq(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;8.选择索引值为小于 3 的 div 元素 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;div:lt(3)&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;9.选择所有的标题元素 $(&quot;#btn9&quot;).click(function()&#123; $(&quot;:header&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;10.选择当前正在执行动画的所有元素 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;:animated&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#x2F;&#x2F;11.选择没有执行动画的最后一个div $(&quot;#btn11&quot;).click(function()&#123; $(&quot;div:not(:animated):last&quot;).css(&quot;background&quot;, &quot;#bbffaa&quot;); &#125;); &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择第一个 div 元素&quot; id&#x3D;&quot;btn1&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择最后一个 div 元素&quot; id&#x3D;&quot;btn2&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择class不为 one 的所有 div 元素&quot; id&#x3D;&quot;btn3&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择索引值为偶数的 div 元素&quot; id&#x3D;&quot;btn4&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择索引值为奇数的 div 元素&quot; id&#x3D;&quot;btn5&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择索引值为大于 3 的 div 元素&quot; id&#x3D;&quot;btn6&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择索引值为等于 3 的 div 元素&quot; id&#x3D;&quot;btn7&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择索引值为小于 3 的 div 元素&quot; id&#x3D;&quot;btn8&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择所有的标题元素&quot; id&#x3D;&quot;btn9&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择当前正在执行动画的所有元素&quot; id&#x3D;&quot;btn10&quot; &#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;选择没有执行动画的最后一个div&quot; id&#x3D;&quot;btn11&quot; &#x2F;&gt; &lt;h3&gt;基本选择器.&lt;&#x2F;h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;one&quot;&gt; id 为 one,class 为 one 的div &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot; id&#x3D;&quot;two&quot; title&#x3D;&quot;test&quot;&gt; id为two,class为one,title为test的div &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;other&quot;&gt;class为mini,title为other&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;test&quot;&gt;class为mini,title为test&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;one&quot;&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot;&gt;class为mini&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;mini&quot; title&#x3D;&quot;tesst&quot;&gt;class为mini,title为tesst&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;display:none;&quot; class&#x3D;&quot;none&quot;&gt;style的display为&quot;none&quot;的div&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;hide&quot;&gt;class为&quot;hide&quot;的div&lt;&#x2F;div&gt; &lt;div&gt; 包含input的type为&quot;hidden&quot;的div&lt;input type&#x3D;&quot;hidden&quot; size&#x3D;&quot;8&quot;&gt; &lt;&#x2F;div&gt; &lt;div id&#x3D;&quot;mover&quot;&gt;正在执行动画的div元素.&lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 全选和全不选Dom的增删改从左到右， 从右到左练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; select &#123; width: 100px; height: 140px; &#125; div &#123; width: 130px; float: left; text-align: center; &#125; &lt;&#x2F;style&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function () &#123; $(&quot;#btn1&quot;).click(function () &#123; $(&quot;#s1 option:selected&quot;).appendTo($(&quot;#s2&quot;)) ; &#125;); $(&quot;#btn2&quot;).click(function () &#123; $(&quot;#s1 option&quot;).appendTo($(&quot;#s2&quot;)) ; &#125;); $(&quot;#btn3&quot;).click(function () &#123; $(&quot;#s2 option:selected&quot;).appendTo($(&quot;#s1&quot;)) ; &#125;); $(&quot;#btn4&quot;).click(function () &#123; $(&quot;#s2 option&quot;).appendTo($(&quot;#s1&quot;)) ; &#125;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;left&quot;&gt; &lt;select multiple&#x3D;&quot;multiple&quot; id&#x3D;&quot;s1&quot; name&#x3D;&quot;sel01&quot;&gt; &lt;option value&#x3D;&quot;opt01&quot;&gt;选项 1&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt02&quot;&gt;选项 2&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt03&quot;&gt;选项 3&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt04&quot;&gt;选项 4&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt05&quot;&gt;选项 5&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt06&quot;&gt;选项 6&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt07&quot;&gt;选项 7&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;opt08&quot;&gt;选项 8&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;button id&#x3D;&quot;btn1&quot;&gt;选中添加到右边&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;btn2&quot;&gt;全部添加到右边&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;div id&#x3D;&quot;rigth&quot;&gt; &lt;select multiple&#x3D;&quot;multiple&quot; id&#x3D;&quot;s2&quot; name&#x3D;&quot;sel02&quot;&gt; &lt;&#x2F;select&gt; &lt;button id&#x3D;&quot;btn3&quot;&gt;选中删除到左边&lt;&#x2F;button&gt; &lt;button id&#x3D;&quot;btn4&quot;&gt;全部删除到左边&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 动态添加删除表格文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;动态增加删除表格记录&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(function () &#123; &#x2F;&#x2F;创建一个复用的函数 var del&#x3D;function () &#123; var $trobj &#x3D;$(this).parent().parent(); var name &#x3D;$trobj.find(&quot;td:last&quot;).text(); &#x2F;** * confirm 是 JavaScript 语言提供的一个确认提示框函数。 你给它传什么， 它就提示什么&lt;br&#x2F;&gt; * 当用户点击了确定， 就返回 true。 当用户点击了取消， 就返回 false *&#x2F; if(confirm(&quot;确认删除&quot;+name+&quot;吗&quot;))&#123; $trobj.remove(); &#125; return false; &#125; &#x2F;&#x2F; 创建一个行标签对象， 添加到显示数据的表格中 $(&quot;#addEmpButton&quot;).click(function () &#123; var name&#x3D;$(&quot;#idName&quot;).val(); var email&#x3D;$(&quot;#idemail&quot;).val(); var salary&#x3D;$(&quot;#idsalary&quot;).val(); var $trObj &#x3D; $(&quot;&lt;tr&gt;&quot; +&quot;&lt;td&gt;&quot; + name + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + email + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + salary + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&lt;a href&#x3D;\\&quot;deleteEmp?id&#x3D;002\\&quot;&gt;Delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&quot; + &quot;&lt;&#x2F;tr&gt;&quot;); &#x2F;&#x2F;添加到显示数据中 $trObj.appendTo( $(&quot;#employeeTable&quot;) ); &#x2F;&#x2F; 给添加的行的 a 标签绑上事件 $trObj.find(&quot;a&quot;).click(del); &#125;); &#x2F;&#x2F; 给删除的 a 标签绑定单击事件 $(&quot;a&quot;).click(del); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;table border&#x3D;&quot;1px&quot; align&#x3D;&quot;center&quot; id&#x3D;&quot;employeeTable&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;&#x2F;th&gt; &lt;th&gt;Email&lt;&#x2F;th&gt; &lt;th&gt;Salary&lt;&#x2F;th&gt; &lt;th&gt; &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;&#x2F;td&gt; &lt;td&gt;tom@tom.com&lt;&#x2F;td&gt; &lt;td&gt;5000&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;deleteEmp?id&#x3D;001&quot;&gt;Delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Jerry&lt;&#x2F;td&gt; &lt;td&gt;jerry@sohu.com&lt;&#x2F;td&gt; &lt;td&gt;8000&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;deleteEmp?id&#x3D;002&quot;&gt;Delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;&#x2F;td&gt;&lt;td&gt;bob@tom.com&lt;&#x2F;td&gt; &lt;td&gt;10000&lt;&#x2F;td&gt; &lt;td&gt;&lt;a href&#x3D;&quot;deleteEmp?id&#x3D;003&quot;&gt;Delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;div id&#x3D;&quot;formDiv&quot; align&#x3D;&quot;center&quot;&gt; &lt;h4&gt;添加新员工&lt;&#x2F;h4&gt; &lt;table&gt; &lt;tr&gt; &lt;td class&#x3D;&quot;word&quot;&gt;name: &lt;&#x2F;td&gt; &lt;td class&#x3D;&quot;inp&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;empName&quot; id&#x3D;&quot;idName&quot; &#x2F;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class&#x3D;&quot;word&quot;&gt;email: &lt;&#x2F;td&gt; &lt;td class&#x3D;&quot;inp&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; id&#x3D;&quot;idemail&quot; &#x2F;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td class&#x3D;&quot;word&quot;&gt;salary: &lt;&#x2F;td&gt; &lt;td class&#x3D;&quot;inp&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;salary&quot; id&#x3D;&quot;idsalary&quot; &#x2F;&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt; &lt;button id&#x3D;&quot;addEmpButton&quot; value&#x3D;&quot;abc&quot;&gt; Submit &lt;&#x2F;button&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; css动画操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.7.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;* 基本 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动 slideDown([spe],[eas],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出 fadeIn([speed],[eas],[fn]) fadeOut([speed],[eas],[fn]) fadeTo([[spe],opa,[eas],[fn]]) fadeToggle([speed,[eas],[fn]]) *&#x2F; $(function()&#123; &#x2F;&#x2F;显示 show() $(&quot;#btn1&quot;).click(function()&#123; $(&quot;#div1&quot;).show(1000); &#125;); &#x2F;&#x2F;隐藏 hide() $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#div1&quot;).hide(1000); &#125;); &#x2F;&#x2F;切换 toggle() $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#div1&quot;).toggle(1000); &#125;); &#x2F;&#x2F;淡入 fadeIn() $(&quot;#btn4&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeIn(500); &#125;); &#x2F;&#x2F;淡出 fadeOut() $(&quot;#btn5&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeOut(500); &#125;); &#x2F;&#x2F;淡化到 fadeTo() $(&quot;#btn6&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeTo(&quot;slow&quot;,Math.random()); &#125;); &#x2F;&#x2F;淡化切换 fadeToggle() $(&quot;#btn7&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeToggle(&quot;slow&quot;,&quot;linear&quot;); &#125;); &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;table style&#x3D;&quot;float: left;&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn1&quot;&gt;显示show()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn2&quot;&gt;隐藏hide()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn3&quot;&gt;显示&#x2F;隐藏切换 toggle()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn4&quot;&gt;淡入fadeIn()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn5&quot;&gt;淡出fadeOut()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn6&quot;&gt;淡化到fadeTo()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button id&#x3D;&quot;btn7&quot;&gt;淡化切换fadeToggle()&lt;&#x2F;button&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;div id&#x3D;&quot;div1&quot; style&#x3D;&quot;float:left;border: 1px solid;background-color: blue;width: 300px;height: 200px;&quot;&gt; jquery动画定义了很多种动画效果，可以很方便的使用这些动画效果 &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"Java_web","slug":"Java-web","permalink":"https://vankood.github.io/categories/Java-web/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JAVA_WEB","slug":"JAVA-WEB","permalink":"https://vankood.github.io/tags/JAVA-WEB/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-11-12T11:57:24.827Z","updated":"2020-11-12T12:07:33.514Z","comments":true,"path":"2020/11/12/正则表达式/","link":"","permalink":"https://vankood.github.io/2020/11/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$只能输入数字：”^[0-9]$”只能输入n位的数字：”^\\d{n}$”只能输入至少n位的数字：”^\\d{n,}$”只能输入m~n位的数字：”^\\d{m,n}$”只能输入零和非零开头的数字：”^(0|[1-9][0-9])$”。只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。只能输入有13位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。只能输入非零的正整数：”^+?[1-9][0-9]$”。只能输入非零的负整数：”^-[1-9][]0-9″$。只能输入长度为3的字符：”^.{3}$”。只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。只能输入由数字和26个英文字母组成的字符串：”^[A-Za-z0-9]+$”。只能输入由数字、26个英文字母或者下划线组成的字符串：”^\\w+$”。验证用户密码：”^[a-zA-Z]\\w{5,17}$”正确格式为：以字母开头，长度在618之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$\\”等字符：”[^%&amp;’,;=?$\\x22]+”。只能输入汉字：”^[\\u4e00-\\u9fa5]{0,}$”验证Email地址：”^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)$”。验证InternetURL：”^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$”。验证电话号码：”^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$”正确格式为：”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX”。验证身份证号（15位或18位数字）：”^\\d{15}|\\d{18}$”。验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”1″～”12″。验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″和”1″～”31″。匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） String.prototype.len=function(){return this.replace(/[^\\x00-\\xff]/g,”aa”).length;}匹配空行的正则表达式：\\n[\\s| ]\\r匹配html标签的正则表达式：&lt;(.*)&gt;(.)&lt;/(.*)&gt;|&lt;(.*)/&gt;匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, “”);}利用正则表达式分解和转换IP地址：下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：function IP2V(ip){re=/(\\d+).(\\d+).(\\d+).(\\d+)/g //匹配IP地址的正则表达式if(re.test(ip)){return RegExp.$1Math.pow(255,3))+RegExp.$2Math.pow(255,2))+RegExp.$3255+RegExp.$41}else{throw new Error(“Not a valid IP address!”)}} 不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：var ip=”10.100.20.168″ip=ip.split(“.”)alert(“IP值是：”+(ip[0]255255255+ip[1]255255+ip[2]*255+ip[3]*1))匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)匹配网址URL的正则表达式：http://([\\w-]+.)+[\\w-]+(/[\\w- ./?%&amp;=])?利用正则表达式限制网页表单里的文本框输入内容：用正则表达式限制只能输入中文：onkeyup=”value=value.replace(/[^\\u4E00-\\u9FA5]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\u4E00-\\u9FA5]/g,”))”用正则表达式限制只能输入全角字符： onkeyup=”value=value.replace(/[^\\uFF00-\\uFFFF]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\uFF00-\\uFFFF]/g,”))”用正则表达式限制只能输入数字：onkeyup=”value=value.replace(/[^\\d]/g,”) “onbeforepaste=”clipboardData.setData (‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))”用正则表达式限制只能输入数字和英文：onkeyup=”value=value.replace(/[\\W]/g,”) “onbeforepaste=”clipboardData.setData (‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))”匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：\\n\\s\\r评注：可以用来删除空白行匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?|&lt;.*? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力匹配首尾空白字符的正则表达式：^\\s*|\\s*$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)评注：表单验证时很实用匹配网址URL的正则表达式 ：[a-zA-z]+://[^\\s]评注：网上流传的版本功能很有限，上面这个基本可以满足需求匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7}评注：匹配形式如 0511-4405222 或 021-87888822匹配腾讯QQ号：[1-9][0-9] {4,}评注：腾讯QQ号从10000开始匹配中国邮政编码：[1-9]\\d{5}(?!\\d)评注：中国邮政编码为6位数字匹配身份证：\\d{15}|\\d{18}评注：中国的身份证为15位或18位匹配ip地址：\\d+.\\d+.\\d+.\\d+评注：提取ip地址时有用匹配特定数字：^[1-9]\\d*$//匹配正整数^-[1-9]\\d*$//匹配负整数^-?[1-9]\\d*$//匹配整数^[1-9]\\d*|0$//匹配非负整数（正整数 + 0）^-[1-9]\\d*|0$//匹配非正整数（负整数 + 0）^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$//匹配正浮点数^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$//匹配负浮点数^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$//匹配浮点数^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$//匹配非负浮点数（正浮点数 + 0）^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：^[A-Za-z]+$//匹配由26个英文字母组成的字符串^[A-Z]+$//匹配由26个英文字母的大写组成的字符串^[a-z]+$//匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$//匹配由数字和26个英文字母组成的字符串^\\w+$//匹配由数字、26个英文字母或者下划线组成的字符串评注：最基本也是最常用的一些表达式整理出来的一些常用的正则表达式 所属分类: JScript(三)Email : /^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)$/isEmail1 : /^\\w+([.-]\\w+)*@\\w+([.-]\\w+)*.\\w+$/;isEmail2 : /^.@[^]*$/;Phone : /^(((\\d{3}))|(\\d{3}-))?((0\\d{2,3})|0\\d{2,3}-)?[1-9]\\d{6,7}$/Mobile : /^(((\\d{3}))|(\\d{3}-))?13\\d{9}$/Url : /^http://[A-Za-z0-9]+.[A-Za-z0-9]+[/=?%-&amp;`@[]\\’:+!]([^&lt;&gt;&quot;&quot;])$/IdCard : /^\\d{15}(\\d{2}[A-Za-z0-9])?$/Currency : /^\\d+(.\\d+)?$/Number : /^\\d+$/Code : /^[1-9]\\d{5}$/QQ : /^[1-9]\\d{4,8}$/Integer : /^[-+]?\\d+$/Double : /^[-+]?\\d+(.\\d+)?$/English : /^[A-Za-z]+$/Chinese : /^[\\u0391-\\uFFE5]+$/UnSafe : /^(([A-Z]|[a-z]|\\d*|[-_\\!@#$%^&amp;*.()[]{}&lt;&gt;?\\/\\’\\”]*)|.{0,5})$|\\s/PassWord :^[\\w]{6,12}$ZipCode : ^[\\d]{6}/^(+\\d+ )?((\\d+) )?[\\d ]+$/; //这个是国际通用的电话号码判断/^(1[0-2]\\d|\\d{1,2})$/;//这个是年龄的判断/^\\d+.\\d{2}$/;//这个是判断输入的是否为货币值应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace([^\\x00-\\xff]/g,”aa”).length;}应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, “”);}匹配空行的正则表达式：\\n[\\s| ]\\r匹配HTML标记的正则表达式：/&lt;(.*)&gt;.&lt;/\\1&gt;|&lt;(.*) /&gt;/匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)匹配Email地址的正则表达式：\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)匹配网址URL的正则表达式：http://([\\w-]+.)+[\\w-]+(/[\\w- ./?%&amp;=])?^\\d+$ //匹配非负整数（正整数 + 0）^[0-9][1-9][0-9]$ //匹配正整数^((-\\d+)|(0+))$ //匹配非正整数（负整数 + 0）^-[0-9][1-9][0-9]$ //匹配负整数^-?\\d+$ //匹配整数^\\d+(.\\d+)?$ //匹配非负浮点数（正浮点数 + 0）^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ //匹配正浮点数^((-\\d+(.\\d+)?)|(0+(.0+)?))$ //匹配非正浮点数（负浮点数 + 0）^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ //匹配负浮点数^(-?\\d+)(.\\d+)?$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;&#x2F; 表示要求字符串中，是否包含字母e &#x2F;&#x2F; var patt &#x3D; new RegExp(&quot;e&quot;); &#x2F;&#x2F; var patt &#x3D; &#x2F;e&#x2F;; &#x2F;&#x2F; 也是正则表达式对象 &#x2F;&#x2F; 表示要求字符串中，是否包含字母a或b或c &#x2F;&#x2F; var patt &#x3D; &#x2F;[abc]&#x2F;; &#x2F;&#x2F; 表示要求字符串，是否包含小写字母 &#x2F;&#x2F; var patt &#x3D; &#x2F;[a-z]&#x2F;; &#x2F;&#x2F; 表示要求字符串，是否包含任意大写字母 &#x2F;&#x2F; var patt &#x3D; &#x2F;[A-Z]&#x2F;; &#x2F;&#x2F; 表示要求字符串，是否包含任意数字 &#x2F;&#x2F; var patt &#x3D; &#x2F;[0-9]&#x2F;; &#x2F;&#x2F; 表示要求字符串，是否包含字母，数字，下划线 &#x2F;&#x2F; var patt &#x3D; &#x2F;\\w&#x2F;; &#x2F;&#x2F; 表示要求 字符串中是否包含至少一个a &#x2F;&#x2F; var patt &#x3D; &#x2F;a+&#x2F;; &#x2F;&#x2F; 表示要求 字符串中是否 *包含* 零个 或 多个a &#x2F;&#x2F; var patt &#x3D; &#x2F;a*&#x2F;; &#x2F;&#x2F; 表示要求 字符串是否包含一个或零个a &#x2F;&#x2F; var patt &#x3D; &#x2F;a?&#x2F;; &#x2F;&#x2F; 表示要求 字符串是否包含连续三个a &#x2F;&#x2F; var patt &#x3D; &#x2F;a&#123;3&#125;&#x2F;; &#x2F;&#x2F; 表示要求 字符串是否包 至少3个连续的a，最多5个连续的a &#x2F;&#x2F; var patt &#x3D; &#x2F;a&#123;3,5&#125;&#x2F;; &#x2F;&#x2F; 表示要求 字符串是否包 至少3个连续的a， &#x2F;&#x2F; var patt &#x3D; &#x2F;a&#123;3,&#125;&#x2F;; &#x2F;&#x2F; 表示要求 字符串必须以a结尾 &#x2F;&#x2F; var patt &#x3D; &#x2F;a$&#x2F;; &#x2F;&#x2F; 表示要求 字符串必须以a打头 &#x2F;&#x2F; var patt &#x3D; &#x2F;^a&#x2F;; &#x2F;&#x2F; 要求字符串中是否*包含* 至少3个连续的a &#x2F;&#x2F; var patt &#x3D; &#x2F;a&#123;3,5&#125;&#x2F;; &#x2F;&#x2F; 要求字符串，从头到尾都必须完全匹配 &#x2F;&#x2F; var patt &#x3D; &#x2F;^a&#123;3,5&#125;$&#x2F;; var patt &#x3D; &#x2F;^\\w&#123;5,12&#125;$&#x2F;; var str &#x3D; &quot;wzg168[[[&quot;; alert( patt.test(str) ); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"JavaScript","slug":"javascript","date":"2020-11-11T09:15:05.396Z","updated":"2020-11-12T11:53:32.053Z","comments":true,"path":"2020/11/11/javascript/","link":"","permalink":"https://vankood.github.io/2020/11/11/javascript/","excerpt":"","text":"JavaScriptJavaScript基础概念Javascript 语言诞生主要是完成页面的数据验证。 因此它运行在客户端， 需要运行浏览器来解析执行 JavaScript 代码。 JavaScript里面的特殊的值JavaScript里特殊的值：undefined: 未定义，所有js变量未赋于初始值的时候，默认值都undefined。null: 空值NaN: 全称是：NotaNumber。非数字。非数值。 关系比较等于： == 等于是简单的做字面值的比较全等于： === 除了做字面值的比较之外， 还会比较两个变量的数据类型 逻辑运算且运算： &amp;&amp;或运算： ||取反运算： ! /*&amp;&amp; 且运算。有两种情况：第一种： 当表达式全为真的时候。 返回最后一个表达式的值。第二种： 当表达式中， 有一个为假的时候。 返回第一个为假的表达式的值|| 或运算第一种情况： 当表达式全为假时， 返回最后一个表达式的值第二种情况： 只要有一个表达式为真。 就会把回第一个为真的表达式的值并且 &amp;&amp; 与运算 和 ||或运算 有短路。短路就是说，当这个&amp;&amp;或||运算有结果了之后。后面的表达式不再执行*/ &amp;&amp; 且运算。有两种情况：第一种： 当表达式全为真的时候。 返回最后一个表达式的值。第二种： 当表达式中， 有一个为假的时候。 返回第一个为假的表达式的值*/var a = “abc”;var b = true;var d = false;var c = null;// alert( a &amp;&amp; b );//true// alert( b &amp;&amp; a );//true// alert( a &amp;&amp; d ); // false// alert( a &amp;&amp; c ); // null/* || 或运算第一种情况： 当表达式全为假时， 返回最后一个表达式的值第二种情况： 只要有一个表达式为真。 就会把回第一个为真的表达式的值*/// alert( d || c ); // null// alert( c|| d ); //false// alert( a || c ); //abc// alert( b || c ); //true js中的事件onload 加载完成事件： 页面加载完成之后， 常用于做页面 js 代码初始化操作onclick 单击事件： 常用于按钮的点击响应操作。onblur 失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。onchange 内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作onsubmit 表单提交事件： 常用于表单提交前， 验证所有表单项是否合法。 Dom模型DOM 全称是Document ObjectModel文档对象模型就是把文档中的标签。属性文本转换成对象来管理。 用户名的校验方法一1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;xiaoyan&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; &#x2F;* * 需求：当用户点击了较验按钮，要获取输出框中的内容。然后验证其是否合法。&lt;br&#x2F;&gt; * 验证的规则是：必须由字母，数字。下划线组成。并且长度是5到12位。 * *&#x2F; function onclickFun()&#123; &#x2F;&#x2F; 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。 var usernameObh&#x3D;document.getElementById(&quot;username&quot;); &#x2F;&#x2F; [object HTMLInputElement] 它就是dom对象 var userText&#x3D;usernameObh.value; var patt &#x3D; &#x2F;^\\w&#123;5,12&#125;$&#x2F;; &#x2F;* * test()方法用于测试某个字符串，是不是匹配我的规则 ， * 匹配就返回true。不匹配就返回false. * *&#x2F; if(patt.test(userText))&#123; alert(&quot;合法&quot;); &#125;else &#123; alert(&quot;不合法&quot;); &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot;&gt; &lt;button onclick&#x3D;&quot;onclickFun()&quot;&gt;校验&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 方法二12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;用户名校验&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; function oneClickFun()&#123; &#x2F;&#x2F; 1 当我们要操作一个标签的时候，一定要先获取这个标签对象。 var usernameobj&#x3D; document.getElementById(&quot;username01&quot;); var userText&#x3D;usernameobj.value; &#x2F;&#x2F;正则表达式 var usernameHtm&#x3D;document.getElementById(&quot;usernameSpan&quot;); var patt &#x3D; &#x2F;^\\w&#123;5,12&#125;$&#x2F;; if(patt.test(userText))&#123; usernameHtm.innerHTML &#x3D; &quot;&lt;img src&#x3D;\\&quot;right.png\\&quot; width&#x3D;\\&quot;18\\&quot; height&#x3D;\\&quot;18\\&quot;&gt; 用户名输入合法&quot;; alert(&quot;用户名输入合法&quot;); &#125;else &#123; usernameHtm.innerHTML &#x3D; &quot;&lt;img src&#x3D;\\&quot;wrong.png\\&quot; width&#x3D;\\&quot;18\\&quot; height&#x3D;\\&quot;18\\&quot;&gt;&quot;; alert(&quot;用户名输入不合法&quot;); &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username01&quot;&gt; &lt;span id&#x3D;&quot;usernameSpan&quot; style&#x3D;&quot;color: red;&quot;&gt; &lt;&#x2F;span&gt; &lt;br&gt; &lt;button onclick&#x3D;&quot;oneClickFun()&quot;&gt;校验&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://vankood.github.io/categories/JavaWeb/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"javaWeb","slug":"javaWeb","permalink":"https://vankood.github.io/tags/javaWeb/"}]},{"title":"杂七杂八","slug":"java8","date":"2020-11-11T02:49:36.726Z","updated":"2020-10-26T19:44:56.000Z","comments":true,"path":"2020/11/11/java8/","link":"","permalink":"https://vankood.github.io/2020/11/11/java8/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 实现trim方法1234567891011121314151617public class vankood_test02 &#123; public static void main(String[] args) &#123; String s=&quot; dwf &quot;; int i=0; int j=s.length(); while(s.startsWith(&quot; &quot;,i))&#123; i++; &#125; while(s.endsWith(&quot; &quot;))&#123; j--; s=s.substring(0,j); &#125; System.out.println(j); String c=s.substring(i,j); System.out.println(c); &#125;&#125; #String类的replaceAll方法 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d+&quot;,&quot;,&quot;); System.out.println(string);结果：,hello,world, 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d&quot;,&quot;,&quot;); System.out.println(string); 结果:,,hello,world, 字符串指定位置反转123456789101112131415public class vankood_test04 &#123; public static void main(String[] args) &#123; int a=3; int b=6; StringBuffer sb=new StringBuffer(); String s=&quot;abcdefghijk&quot;; sb.append(s.substring(0,a)); for(int i=b;i&gt;a;i--)&#123; sb.append(s.substring(i-1,i)); &#125; sb.append(s.substring(b,s.length())); System.out.println(sb); &#125;&#125; 字符串出现次数获取一个字符串在另一个字符串中出现的次数。比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 1234567891011121314public class vankood_test05 &#123; public static void main(String[] args) &#123; String s=&quot;absdwabdwrrab&quot;; int i=0; int j=0; while(s.contains(&quot;ab&quot;))&#123; i++; s=s.substring(s.indexOf(&quot;ab&quot;)+1,s.length()); &#125; System.out.println(i); &#125;&#125; 字符串自然排序123456789101112131415import java.util.Arrays;public class vankood_test06 &#123; public static void main(String[] args) &#123; String s=&quot;abdgrgregr&quot;; char [] c=s.toCharArray(); Arrays.sort(c); System.out.println(c); char[] d=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; System.out.println(d); &#125;&#125; null长度1234567891011public class vankood_test002 &#123; public static void main(String[] args) &#123; String str&#x3D;null; StringBuffer sb&#x3D;new StringBuffer(); sb.append(str); System.out.println(sb.length()); System.out.println(sb); &#125;&#125; 结果：4 null","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"反射_基础","slug":"反射_基础","date":"2020-11-04T11:03:11.707Z","updated":"2020-11-11T09:14:55.828Z","comments":true,"path":"2020/11/04/反射_基础/","link":"","permalink":"https://vankood.github.io/2020/11/04/%E5%8F%8D%E5%B0%84_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"反射基本概念获取claa类实例的四种方法123456789101112131415161718192021//获取Class的实例的四种方式 @Test public void Test03() throws ClassNotFoundException &#123; //方式一：调用运行时类的属性：.class Class clazz=Person.class; System.out.println(clazz); //方式二：通过运行时类的对象,调用getClass() Person p1=new Person(); Class clazz2=p1.getClass(); System.out.println(clazz2); //方式三：调用Class的静态方法：forName(String classPath) Class clazz3=Class.forName(&quot;Person&quot;); System.out.println(clazz3); //方式四：使用类的加载器：ClassLoader ClassLoader classLoader = vanned_02.class.getClassLoader(); Class clazz4=classLoader.loadClass(&quot;Person&quot;); System.out.println(clazz4); &#125; 读取配置文件的两种方式1234567891011121314151617181920212223public void test2() throws Exception &#123; Properties pros = new Properties(); //此时的文件默认在当前的module下。 //读取配置文件的方式一：// FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);// FileInputStream fis = new FileInputStream(&quot;src\\\\jdbc1.properties&quot;);// pros.load(fis); //读取配置文件的方式二：使用ClassLoader //配置文件默认识别为：当前module的src下 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(is); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;user = &quot; + user + &quot;,password = &quot; + password); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"枚举类和注解_基础","slug":"枚举类和注解","date":"2020-10-28T09:01:30.070Z","updated":"2020-11-01T12:56:21.839Z","comments":true,"path":"2020/10/28/枚举类和注解/","link":"","permalink":"https://vankood.github.io/2020/10/28/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"枚举类和注解枚举方法枚举类的使用1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类2.当需要定义一组常量时，强烈建议使用枚举类3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 如何定义枚举类方式一：jdk5.0之前，自定义枚举类方式二：jdk5.0，可以使用enum关键字定义枚举类 Enum类中的常用方法：values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 使用enum关键字定义的枚举类实现接口的情况情况一：实现接口，在enum类中实现抽象方法情况二：让枚举类的对象分别实现接口中的抽象方法 jdk5.0之前使用方法123456789101112131415161718192021222324252627282930313233343536373839public class vankood_001 &#123; public static void main(String[] args) &#123; Season Spring&#x3D;Season.SPRING; System.out.println(Spring); &#125;&#125;class Season&#123; &#x2F;&#x2F;1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; private Season(String seasonName,String seasonDesc)&#123; this.seasonName&#x3D;seasonName; this.seasonDesc&#x3D;seasonDesc; &#125; &#x2F;&#x2F;3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING &#x3D; new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER &#x3D; new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN &#x3D; new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER &#x3D; new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); public String getSeasonName()&#123; return seasonName; &#125; public String getSeasonDesc()&#123; return seasonDesc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName&#x3D;&#39;&quot; + seasonName + &#39;\\&#39;&#39; + &quot;, seasonDesc&#x3D;&#39;&quot; + seasonDesc + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125;&#125; jdk5.0之后使用方法（枚举类型）``````","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"杂七杂八","slug":"杂七杂八","date":"2020-10-26T12:03:16.494Z","updated":"2020-10-26T19:44:56.000Z","comments":true,"path":"2020/10/26/杂七杂八/","link":"","permalink":"https://vankood.github.io/2020/10/26/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 实现trim方法1234567891011121314151617public class vankood_test02 &#123; public static void main(String[] args) &#123; String s=&quot; dwf &quot;; int i=0; int j=s.length(); while(s.startsWith(&quot; &quot;,i))&#123; i++; &#125; while(s.endsWith(&quot; &quot;))&#123; j--; s=s.substring(0,j); &#125; System.out.println(j); String c=s.substring(i,j); System.out.println(c); &#125;&#125; #String类的replaceAll方法 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d+&quot;,&quot;,&quot;); System.out.println(string);结果：,hello,world, 123String str=&quot;12hello34world12&quot;; String string=str.replaceAll(&quot;\\\\d&quot;,&quot;,&quot;); System.out.println(string); 结果:,,hello,world, 字符串指定位置反转123456789101112131415public class vankood_test04 &#123; public static void main(String[] args) &#123; int a=3; int b=6; StringBuffer sb=new StringBuffer(); String s=&quot;abcdefghijk&quot;; sb.append(s.substring(0,a)); for(int i=b;i&gt;a;i--)&#123; sb.append(s.substring(i-1,i)); &#125; sb.append(s.substring(b,s.length())); System.out.println(sb); &#125;&#125; 字符串出现次数获取一个字符串在另一个字符串中出现的次数。比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 1234567891011121314public class vankood_test05 &#123; public static void main(String[] args) &#123; String s=&quot;absdwabdwrrab&quot;; int i=0; int j=0; while(s.contains(&quot;ab&quot;))&#123; i++; s=s.substring(s.indexOf(&quot;ab&quot;)+1,s.length()); &#125; System.out.println(i); &#125;&#125; 字符串自然排序123456789101112131415import java.util.Arrays;public class vankood_test06 &#123; public static void main(String[] args) &#123; String s=&quot;abdgrgregr&quot;; char [] c=s.toCharArray(); Arrays.sort(c); System.out.println(c); char[] d=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; System.out.println(d); &#125;&#125; null长度1234567891011public class vankood_test002 &#123; public static void main(String[] args) &#123; String str&#x3D;null; StringBuffer sb&#x3D;new StringBuffer(); sb.append(str); System.out.println(sb.length()); System.out.println(sb); &#125;&#125; 结果：4 null","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"Hello World","slug":"异常处理_基础","date":"2020-10-26T09:33:19.046Z","updated":"2020-10-18T12:35:16.418Z","comments":true,"path":"2020/10/26/异常处理_基础/","link":"","permalink":"https://vankood.github.io/2020/10/26/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hamapi huasongyuanCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-26T09:33:14.891Z","updated":"2020-10-18T12:35:16.418Z","comments":true,"path":"2020/10/26/hello-world/","link":"","permalink":"https://vankood.github.io/2020/10/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start hamapi huasongyuanCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"}]},{"title":"hashmap的底层实现原理","slug":"hashmap的底层实现原理","date":"2020-10-23T06:23:26.079Z","updated":"2020-10-26T13:34:57.454Z","comments":true,"path":"2020/10/23/hashmap的底层实现原理/","link":"","permalink":"https://vankood.github.io/2020/10/23/hashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"hashmap的底层实现原理基本概念程序：是为完成特定任务、某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程：是程序的一次执行过程。或者正在运行的一个程序。是一个动态过程：有他自身产生、存在、消亡的过程。线程：程序内部的一条执行路径。线程是程序执行的一条路径, 一个进程中可以包含多条线程。多线程并发执行可以提高程序的效率, 可以同时完成多项工作。 并行：多个cpu同时执行多个任务。比如多个人做不同的事情。并发：一个cpu（采用时间片）同时执行多个任务。比如：秒杀、多个人同时做一件事情。 守护线程用来服务于用户线程；不需要上层逻辑介入。当线程只剩下守护线程的时候,JVM就会退出；补充一点如果还有其他的任意一个用户线程还在，JVM就不会退出。 java垃圾回收就是一种典型的守护线程。 守护线程是用来服务用户线程的，通过在start()方法前调用 1thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。 用户线程：我们平常创建的普通线程。 线程的创建和使用方式一：继承于Thread类1234567891011121314151617181920212223242526272829303132/** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * &lt;p&gt; * 例子：遍历100以内的所有的偶数 * * @author vankood */public class Vankood_01 &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread m1=new MyThread(); //4. 通过此对象调用start() m1.start(); for(int i=0;i&lt;10000;i++)&#123; System.out.println(&quot;主线程&quot;); &#125; &#125;&#125;//1. 创建一个继承于Thread类的子类class MyThread extends Thread&#123; //2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 @Override public void run()&#123; System.out.println(&quot;分线程&quot;); &#125; &#125;&#125; 例子123456789101112131415161718192021222324252627282930313233343536373839/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * * * @author shkstart * @create 2019-02-13 下午 2:16 */public class vankood_02 &#123; public static void main(String[] args) &#123; Mythread1 m1=new Mythread1(); Mythread2 m2=new Mythread2(); m1.start(); m2.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class Mythread2 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125; 匿名子类方式创建线程1234567891011121314151617181920212223public class vankood_03 &#123; public static void main(String[] args) &#123; new Thread(&quot;线程一&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程二&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方式二：实现Runnable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * * @author shkstart * @create 2019-02-13 下午 4:34 */class Mythread implements Runnable&#123;// 1. 创建一个实现了Runnable接口的类 @Override public void run() &#123; // 2. 实现类去实现Runnable中的抽象方法：run() for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class vankood_04 &#123; public static void main(String[] args) &#123; Mythread mt=new Mythread(); //3. 创建实现类的对象 Thread t1=new Thread(mt); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.setName(&quot;线程一&quot;); Mythread mt2=new Mythread(); Thread t2=new Thread(mt2); t2.setName(&quot;线程二&quot;); t1.start(); //5. 通过Thread类的对象调用start() t2.start(); &#125;&#125; 两种方式的对比比较创建线程的两种方式。 开发中：优先选择：实现Runnable接口的方式** 原因： ** 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系： public class Thread implements Runnable Thread类实现了Runnable接口。 相同点： 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 线程的常用方法 测试Thread中的常用方法： start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程1Thread.currentThread().getName() getName():获取当前线程的名字 setName():设置当前线程的名字1HelloThread h1 &#x3D; new HelloThread(&quot;线程一&quot;); yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 1. MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class HelloThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123;// try &#123;// sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i % 20 == 0)&#123;// yield();// &#125; &#125; &#125; public HelloThread(String name)&#123; super(name); &#125;&#125;public class ThreadMethodTest &#123; public static void main(String[] args) &#123; HelloThread h1 = new HelloThread(&quot;Thread：1&quot;);// h1.setName(&quot;线程一&quot;); //设置分线程的优先级 h1.setPriority(Thread.MAX_PRIORITY); h1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i == 20)&#123;// try &#123;// h1.join();// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125; &#125;// System.out.println(h1.isAlive()); &#125;&#125; 线程的生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 *新建**：就是刚使用new方法，new出来的线程； *就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; *运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; *阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; *死亡**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;线程的同步在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 synchronized(同步监视器)&#123; //需要被同步的代码 &#125; ``` 说明： 1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。### 方式二：同步方法。如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 5.同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 #### 实现Runnable接口的线程同步（同步代码块） ```java class Window1 implements Runnable&#123; private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() &#123; // Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; class Dog&#123; &#125; 实现Runnable接口的线程同步（同步方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 *&#x2F;class Window2 extends Thread&#123; private static int ticket &#x3D; 100; private static Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; &#x2F;&#x2F;正确的&#x2F;&#x2F; synchronized (obj)&#123; synchronized (Window2.class)&#123;&#x2F;&#x2F;Class clazz &#x3D; Window2.class,Window2.class只会加载一次 &#x2F;&#x2F;错误的方式：this代表着t1,t2,t3三个对象&#x2F;&#x2F; synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 &#x3D; new Window2(); Window2 t2 &#x3D; new Window2(); Window2 t3 &#x3D; new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式三：Lock锁 — JDK5.0新增 1.synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.优先使用顺序： Lock 同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Window implements Runnable&#123; private int ticket = 10; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true);//true表示公平锁 @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 线程的通信notify和notifyallcom.atguigu.java2;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;** * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 * * 涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 * * 说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 * * @author shkstart * @create 2019-02-15 下午 4:21 *&#x2F;class Number implements Runnable&#123; private int number &#x3D; 1; private Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;&#x3D; 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; &#x2F;&#x2F;使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number &#x3D; new Number(); Thread t1 &#x3D; new Thread(number); Thread t2 &#x3D; new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; jdk5.0新增线程创建方式","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"IO流_基础","slug":"IO流_基础","date":"2020-10-22T09:08:48.799Z","updated":"2020-11-02T14:37:44.718Z","comments":true,"path":"2020/10/22/IO流_基础/","link":"","permalink":"https://vankood.github.io/2020/10/22/IO%E6%B5%81_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"IO流流的分类1.操作数据单位：字节流、字符流2.数据的流向：输入流、输出流3.流的角色：节点流、处理流 二、流的体系结构 File类的使用字符流读取文本文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class FileReaderWriterTest &#123; public static void main(String[] args) &#123; File file = new File(&quot;hello.txt&quot;);//相较于当前工程 System.out.println(file.getAbsolutePath()); File file1 = new File(&quot;day09\\\\hello.txt&quot;); System.out.println(file1.getAbsolutePath()); &#125; /* 将day09下的hello.txt文件内容读入程序中，并输出到控制台 说明点： 1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1 2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理 3. 读入的文件一定要存在，否则就会报FileNotFoundException。 */ @Test public void testFileReader()&#123; FileReader fr = null; try &#123; //1.实例化File类的对象，指明要操作的文件 File file = new File(&quot;hello.txt&quot;);//相较于当前Module //2.提供具体的流 fr = new FileReader(file); //3.数据的读入 //read():返回读入的一个字符。如果达到文件末尾，返回-1 //方式一：// int data = fr.read();// while(data != -1)&#123;// System.out.print((char)data);// data = fr.read();// &#125; //方式二：语法上针对于方式一的修改 int data; while((data = fr.read()) != -1)&#123; System.out.print((char)data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流的关闭操作// try &#123;// if(fr != null)// fr.close();// &#125; catch (IOException e) &#123;// e.printStackTrace();// &#125; //或 if(fr != null)&#123; try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 字符流读取文本文件(升级版)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void testFileReader1() &#123; FileReader fr = null; try &#123; //1.File类的实例化 File file = new File(&quot;hello.txt&quot;); //2.FileReader流的实例化 fr = new FileReader(file); //3.读入的操作 //read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1 char[] cbuf = new char[5]; int len; while((len = fr.read(cbuf)) != -1)&#123; //方式一： //错误的写法// for(int i = 0;i &lt; cbuf.length;i++)&#123;// System.out.print(cbuf[i]);// &#125; //正确的写法// for(int i = 0;i &lt; len;i++)&#123;// System.out.print(cbuf[i]);// &#125; //方式二： //错误的写法,对应着方式一的错误的写法// String str = new String(cbuf);// System.out.print(str); //正确的写法 String str = new String(cbuf,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fr != null)&#123; //4.资源的关闭 try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /* 从内存中写出数据到硬盘的文件里。 说明：1. 输出操作，对应的File可以不存在的。并不会报异常2.File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。 File对应的硬盘中的文件如果存在： 如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖 如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容 fw = new FileWriter(file,false); */ 文本文件的复制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 public void testFileReaderFileWriter() &#123; FileReader fr &#x3D; null; FileWriter fw &#x3D; null; try &#123; &#x2F;&#x2F;1.创建File类的对象，指明读入和写出的文件 File srcFile &#x3D; new File(&quot;hello.txt&quot;); File destFile &#x3D; new File(&quot;hello2.txt&quot;); &#x2F;&#x2F;2.创建输入流和输出流的对象 fr &#x3D; new FileReader(srcFile); fw &#x3D; new FileWriter(destFile); &#x2F;&#x2F;3.数据的读入和写出操作 char[] cbuf &#x3D; new char[5]; int len;&#x2F;&#x2F;记录每次读入到cbuf数组中的字符的个数 while((len &#x3D; fr.read(cbuf)) !&#x3D; -1)&#123; &#x2F;&#x2F;每次写出len个字符 fw.write(cbuf,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; &#x2F;&#x2F;4.关闭流资源 &#x2F;&#x2F;方式一：&#x2F;&#x2F; try &#123;&#x2F;&#x2F; if(fw !&#x3D; null)&#x2F;&#x2F; fw.close();&#x2F;&#x2F; &#125; catch (IOException e) &#123;&#x2F;&#x2F; e.printStackTrace();&#x2F;&#x2F; &#125;finally&#123;&#x2F;&#x2F; try &#123;&#x2F;&#x2F; if(fr !&#x3D; null)&#x2F;&#x2F; fr.close();&#x2F;&#x2F; &#125; catch (IOException e) &#123;&#x2F;&#x2F; e.printStackTrace();&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125; &#x2F;&#x2F;方式二： try &#123; if(fw !&#x3D; null) fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fr !&#x3D; null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 指定路径复制图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//指定路径下文件的复制 public void copyFile(String srcPath,String destPath)&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; // File srcFile = new File(srcPath); File destFile = new File(destPath); // fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); //复制的过程 byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer)) != -1)&#123; fos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null)&#123; // try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Test public void testCopyFile()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\01-视频.avi&quot;; String destPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\02-视频.avi&quot;;// String srcPath = &quot;hello.txt&quot;;// String destPath = &quot;hello3.txt&quot;; copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;复制操作花费的时间为：&quot; + (end - start));//618 &#125; 缓冲流1.缓冲流： BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 缓冲流复制文本文件(字符流) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 public void testBufferedReaderBufferedWriter()&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; //创建文件和相应的流 br = new BufferedReader(new FileReader(new File(&quot;dbcp.txt&quot;))); bw = new BufferedWriter(new FileWriter(new File(&quot;dbcp1.txt&quot;))); //读写操作 //方式一：使用char[]数组// char[] cbuf = new char[1024];// int len;// while((len = br.read(cbuf)) != -1)&#123;// bw.write(cbuf,0,len);// // bw.flush();// &#125; //方式二：使用String String data; while((data = br.readLine()) != null)&#123; //方法一：// bw.write(data + &quot;\\n&quot;);//data中不包含换行符 //方法二： bw.write(data);//data中不包含换行符 bw.newLine();//提供换行的操作 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 if(bw != null)&#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 实现文件的复制(复制在一个路径下，字节流)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//实现文件复制的方法 public void copyFileWithBuffered(String srcPath,String destPath)&#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1.造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2.造流 //2.1 造节点流 FileInputStream fis = new FileInputStream((srcFile)); FileOutputStream fos = new FileOutputStream(destFile); //2.2 造缓冲流 bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3.复制的细节：读取、写入 byte[] buffer = new byte[1024]; int len; while((len = bis.read(buffer)) != -1)&#123; bos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 if(bos != null)&#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(bis != null)&#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.// fos.close();// fis.close(); &#125; &#125; @Test public void testCopyFileWithBuffered()&#123; long start = System.currentTimeMillis(); String srcPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\01-视频.avi&quot;; String destPath = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\03-视频.avi&quot;; copyFileWithBuffered(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;复制操作花费的时间为：&quot; + (end - start));//618 - 176 &#125; 转换流的使用转换流1.转换流：属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流 OutputStreamWriter：将一个字符的输出流转换为字节的输出流 2.作用：提供字节流与字符流之间的转换3.解码：字节、字节数组 —&gt;字符数组、字符串 编码：字符数组、字符串 —&gt; 字节、字节数组4.字符集ASCII：美国标准信息交换码。用一个字节的7位可以表示。ISO8859-1：拉丁码表。欧洲码表 用一个字节的8位表示。GB2312：中国的中文编码表。最多两个字节编码所有字符GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 utf-8转换成gbk1234567891011121314151617181920212223242526@Test public void test2() throws Exception &#123; &#x2F;&#x2F;1.造文件、造流 File file1 &#x3D; new File(&quot;dbcp.txt&quot;); File file2 &#x3D; new File(&quot;dbcp_gbk.txt&quot;); FileInputStream fis &#x3D; new FileInputStream(file1); FileOutputStream fos &#x3D; new FileOutputStream(file2); InputStreamReader isr &#x3D; new InputStreamReader(fis,&quot;utf-8&quot;); OutputStreamWriter osw &#x3D; new OutputStreamWriter(fos,&quot;gbk&quot;); &#x2F;&#x2F;2.读写过程 char[] cbuf &#x3D; new char[20]; int len; while((len &#x3D; isr.read(cbuf)) !&#x3D; -1)&#123; osw.write(cbuf,0,len); &#125; &#x2F;&#x2F;3.关闭资源 isr.close(); osw.close(); &#125; 123456789101112131415161718192021222324public class InputStreamReaderTest &#123; &#x2F;* 此时处理异常的话，仍然应该使用try-catch-finally InputStreamReader的使用，实现字节的输入流到字符的输入流的转换 *&#x2F; @Test public void test1() throws IOException &#123; FileInputStream fis &#x3D; new FileInputStream(&quot;dbcp.txt&quot;);&#x2F;&#x2F; InputStreamReader isr &#x3D; new InputStreamReader(fis);&#x2F;&#x2F;使用系统默认的字符集 &#x2F;&#x2F;参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集 InputStreamReader isr &#x3D; new InputStreamReader(fis,&quot;UTF-8&quot;);&#x2F;&#x2F;使用系统默认的字符集 char[] cbuf &#x3D; new char[20]; int len; while((len &#x3D; isr.read(cbuf)) !&#x3D; -1)&#123; String str &#x3D; new String(cbuf,0,len); System.out.print(str); &#125; isr.close(); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"常用类_基础","slug":"常用类_基础","date":"2020-10-21T02:23:41.790Z","updated":"2020-10-27T12:23:02.981Z","comments":true,"path":"2020/10/21/常用类_基础/","link":"","permalink":"https://vankood.github.io/2020/10/21/%E5%B8%B8%E7%94%A8%E7%B1%BB_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"常用类String类String类：代表字符串，java程序中所有的字符串字面值（如“abc”）都作为此类的实例实现。String是一个final类，代表不可变序列源码： 1234567891011121314151617181920212223242526272829303132333435363738 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; &#x2F;** The value is used for character storage. *&#x2F; private final char value[]; &#x2F;** Cache the hash code for the string *&#x2F; private int hash; &#x2F;&#x2F; Default to 0 &#96;&#96;&#96; ![string.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;pgmIxRirzBkAYqT.png)String stri&#x3D;&quot;abc&quot;与 String str2&#x3D;new String(&quot;abc&quot;)的区别![string2.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;DQApK56luVkvZTF.png)![string3.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;T7Kna1UuDXqfko6.png)![String4.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;c3evpKsWG7hVaYO.png)**intern方法**将返回值放回到常量池中### 使用陷阱**String s1 &#x3D;&quot;a&quot;;** 说明:在字符串常量池中创建了一个字面量为&quot;a&quot;的字符串。 **s1 &#x3D;s1 +&quot;b&quot;** 说明:实际上原来的&quot;a&quot;字符串对象已经丢弃了,现在在堆空间中产生了一个字符串s1+&quot;b&quot; (也就是&quot;ab&quot;)。如果多次执行这些改变串内容的操作,会导致大量副本字符串对象存留在内存中,降低效率。如果这样的操作放到循环中,会极大影响程序的性能。 **String s2 &#x3D; &quot;ab&quot;**; 说明:直接在字符串常量池中创建一个字面量为&quot;ab&quot;的字符串。 **String s3 &#x3D;&quot;a&quot;+ &quot;b&quot;**; 说明: s3指向字符串常量池中已经创建的&quot;ab&quot;的字符串。 **String s4 &#x3D; s1.intern();** 说明:堆空间的s1对象在调用intern()之后,会将常量池中已经存在的&quot;ab&quot;字符串赋值给s4.### 常用方法![string5.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;ZJzDh7iweRuA3Kn.png)![string6.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;nOW7If543HlhPYU.png)![string8.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;10&#x2F;22&#x2F;iGQxJToUXhDC29g.png)### 面试题 public void test4()&#123; String s1 = &quot;javaEEhadoop&quot;; String s2 = &quot;javaEE&quot;; String s3 = s2 + &quot;hadoop&quot;; System.out.println(s1 == s3);//false final String s4 = &quot;javaEE&quot;;//s4:常量 String s5 = s4 + &quot;hadoop&quot;; System.out.println(s1 == s5);//true &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889### String跟byte[]之间的转换编码：String --&gt; byte[]:调用String的getBytes()解码：byte[] --&gt; String:调用String的构造器编码：字符串 --&gt;字节 (看得懂 ---&gt;看不懂的二进制数据)解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）### String类型的一些转换 &#96;&#96;&#96;java public class StringTest1 &#123; &#x2F;* String 与 byte[]之间的转换 编码：String --&gt; byte[]:调用String的getBytes() 解码：byte[] --&gt; String:调用String的构造器 编码：字符串 --&gt;字节 (看得懂 ---&gt;看不懂的二进制数据) 解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 *&#x2F; @Test public void test3() throws UnsupportedEncodingException &#123; String str1 &#x3D; &quot;abc123中国&quot;; byte[] bytes &#x3D; str1.getBytes();&#x2F;&#x2F;使用默认的字符集，进行编码。 System.out.println(Arrays.toString(bytes)); byte[] gbks &#x3D; str1.getBytes(&quot;gbk&quot;);&#x2F;&#x2F;使用gbk字符集进行编码。 System.out.println(Arrays.toString(gbks)); System.out.println(&quot;******************&quot;); String str2 &#x3D; new String(bytes);&#x2F;&#x2F;使用默认的字符集，进行解码。 System.out.println(str2); String str3 &#x3D; new String(gbks); System.out.println(str3);&#x2F;&#x2F;出现乱码。原因：编码集和解码集不一致！ String str4 &#x3D; new String(gbks, &quot;gbk&quot;); System.out.println(str4);&#x2F;&#x2F;没有出现乱码。原因：编码集和解码集一致！ &#125; &#x2F;* String 与 char[]之间的转换 String --&gt; char[]:调用String的toCharArray() char[] --&gt; String:调用String的构造器 *&#x2F; @Test public void test2()&#123; String str1 &#x3D; &quot;abc123&quot;; &#x2F;&#x2F;题目： a21cb3 char[] charArray &#x3D; str1.toCharArray(); for (int i &#x3D; 0; i &lt; charArray.length; i++) &#123; System.out.println(charArray[i]); &#125; char[] arr &#x3D; new char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; String str2 &#x3D; new String(arr); System.out.println(str2); &#125; &#x2F;* 复习： String 与基本数据类型、包装类之间的转换。 String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx) *&#x2F; @Test public void test1()&#123; String str1 &#x3D; &quot;123&quot;; &#x2F;&#x2F; int num &#x3D; (int)str1;&#x2F;&#x2F;错误的 int num &#x3D; Integer.parseInt(str1); String str2 &#x3D; String.valueOf(num);&#x2F;&#x2F;&quot;123&quot; String str3 &#x3D; num + &quot;&quot;; System.out.println(str1 &#x3D;&#x3D; str3); &#125; &#125; String matches StringBufferStringBuffer方法 String、StringBuffer、StringBuilder三者的异同 String:不可变的字符序列；底层使用char[]存储 StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 源码分析： 123456789101112131415String str = new String();//char[] value = new char[0]; String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。 System.out.println(sb1.length());// sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;; sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;; StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16]; //问题1. System.out.println(sb2.length());//3 //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) JDK8之前的时间API java.lang.System类System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 java.util.Date类表示特定的瞬间，精确到毫秒**getTime():**返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。**toString():**把此 Date 对象转换为以下形式的 String： dow mon ddhh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue,Wed, Thu, Fri, Sat)， zzz是时间标准。 1.两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象构造器二：创建指定毫秒数的Date对象 2.两个方法的使用 toString():显示当前的年、月、日、时、分、秒getTime():获取当前Date对象对应的毫秒数。（时间戳） 3.java.sql.Date对应着数据库中的日期类型的变量 如何实例化如何将java.util.Date对象转换为java.sql.Date对象 1234567891011121314151617181920212223242526272829303132333435 public void test2()&#123; //构造器一：Date()：创建一个对应当前时间的Date对象 Date date1 = new Date(); System.out.println(date1.toString());//Sat Feb 16 16:35:31 GMT+08:00 2019 System.out.println(date1.getTime());//1550306204104 //构造器二：创建指定毫秒数的Date对象 Date date2 = new Date(155030620410L); System.out.println(date2.toString()); //创建java.sql.Date对象 java.sql.Date date3 = new java.sql.Date(35235325345L); System.out.println(date3);//1971-02-13 //如何将java.util.Date对象转换为java.sql.Date对象 //情况一：// Date date4 = new java.sql.Date(2343243242323L);// java.sql.Date date5 = (java.sql.Date) date4; //情况二： Date date6 = new Date(); java.sql.Date date7 = new java.sql.Date(date6.getTime()); &#125; //1.System类中的currentTimeMillis() @Test public void test1()&#123; long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); &#125;&#125; 日期和字符串相互转换1234567891011121314 //格式化：日期 ---&gt;字符串 Date date = new Date(); System.out.println(date); String format = sdf.format(date); System.out.println(format); //解析：格式化的逆过程，字符串 ---&gt; 日期 String str = &quot;19-12-18 上午11:43&quot;; Date date1 = sdf.parse(str); System.out.println(date1);``` //*************按照指定的方式格式化和解析：调用带参的构造器***************** // SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;); SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String format1 = sdf1.format(date); System.out.println(format1);//2019-02-18 11:48:27 //解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现), //否则，抛异常 Date date2 = sdf1.parse(&quot;2020-02-18 11:48:27&quot;); System.out.println(date2); 12345678910111213### 字符串&quot;2020-09-08&quot;转换为java.sql.Date &#96;&#96;&#96;java public void testExer() throws ParseException &#123; String birth &#x3D; &quot;2020-09-08&quot;; SimpleDateFormat sdf1 &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date &#x3D; sdf1.parse(birth); &#x2F;&#x2F; System.out.println(date); java.sql.Date birthDate &#x3D; new java.sql.Date(date.getTime()); System.out.println(birthDate); &#125; java.util.Calendar(日历)类Calendar类是一个抽象类，不能实例化 获取Calendar实例的方法 使用Calendar.getInstance()方法 调用它的子类GregorianCalendar的构造器。 1Calendar calendar &#x3D; Calendar.getInstance(); get操作1234&#x2F;&#x2F;get()int days &#x3D; calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days);System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); set操作12345//set() //calendar可变性 calendar.set(Calendar.DAY_OF_MONTH,22); days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); add操作 123calendar.add(Calendar.DAY_OF_MONTH,-3);days = calendar.get(Calendar.DAY_OF_MONTH);System.out.println(days); getTime()操作123&#x2F;&#x2F;getTime():日历类---&gt; Date Date date &#x3D; calendar.getTime(); System.out.println(date); setTime()操作1234Date date1 &#x3D; new Date(); calendar.setTime(date1); days &#x3D; calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); JDK8中出现的新的类12345678910111213public void test1()&#123; &#x2F;&#x2F;now():获取当前的日期、时间、日期+时间 LocalDate localDate &#x3D; LocalDate.now(); LocalTime localTime &#x3D; LocalTime.now(); LocalDateTime localDateTime &#x3D; LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); &#x2F;&#x2F;of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); LocalDate中的get方法12345678910111213public void test1()&#123; &#x2F;&#x2F;now():获取当前的日期、时间、日期+时间 LocalDate localDate &#x3D; LocalDate.now(); LocalTime localTime &#x3D; LocalTime.now(); LocalDateTime localDateTime &#x3D; LocalDateTime.now(); System.out.println(localDate); System.out.println(localTime); System.out.println(localDateTime); &#x2F;&#x2F;of():设置指定的年、月、日、时、分、秒。没有偏移量 LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2020, 10, 6, 13, 23, 43); System.out.println(localDateTime1); LocalDate中的with方法(设置相关属性) 12345678910111213141516&#x2F;&#x2F;withXxx():设置相关的属性 LocalDate localDate1 &#x3D; localDate.withDayOfMonth(22); System.out.println(localDate); System.out.println(localDate1); LocalDateTime localDateTime2 &#x3D; localDateTime.withHour(4); System.out.println(localDateTime); System.out.println(localDateTime2); &#x2F;&#x2F;不可变性 LocalDateTime localDateTime3 &#x3D; localDateTime.plusMonths(3); System.out.println(localDateTime); System.out.println(localDateTime3); LocalDateTime localDateTime4 &#x3D; localDateTime.minusDays(6); System.out.println(localDateTime); System.out.println(localDateTime4); Instant12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 @Test public void test2()&#123; &#x2F;&#x2F;now():获取本初子午线对应的标准时间 Instant instant &#x3D; Instant.now(); System.out.println(instant);&#x2F;&#x2F;2019-02-18T07:29:41.719Z &#x2F;&#x2F;添加时间的偏移量 OffsetDateTime offsetDateTime &#x3D; instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);&#x2F;&#x2F;2019-02-18T15:32:50.611+08:00 &#x2F;&#x2F;toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数 ---&gt; Date类的getTime() long milli &#x3D; instant.toEpochMilli(); System.out.println(milli); &#x2F;&#x2F;ofEpochMilli():通过给定的毫秒数，获取Instant实例 --&gt;Date(long millis) Instant instant1 &#x3D; Instant.ofEpochMilli(1550475314878L); System.out.println(instant1); &#125; &#x2F;* DateTimeFormatter:格式化或解析日期、时间 类似于SimpleDateFormat *&#x2F; @Test public void test3()&#123;&#x2F;&#x2F; 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter &#x3D; DateTimeFormatter.ISO_LOCAL_DATE_TIME; &#x2F;&#x2F;格式化:日期--&gt;字符串 LocalDateTime localDateTime &#x3D; LocalDateTime.now(); String str1 &#x3D; formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);&#x2F;&#x2F;2019-02-18T15:42:18.797 &#x2F;&#x2F;解析：字符串 --&gt;日期 TemporalAccessor parse &#x3D; formatter.parse(&quot;2019-02-18T15:42:18.797&quot;); System.out.println(parse);&#x2F;&#x2F; 方式二：&#x2F;&#x2F; 本地化相关的格式。如：ofLocalizedDateTime()&#x2F;&#x2F; FormatStyle.LONG &#x2F; FormatStyle.MEDIUM &#x2F; FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 &#x3D; DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); &#x2F;&#x2F;格式化 String str2 &#x3D; formatter1.format(localDateTime); System.out.println(str2);&#x2F;&#x2F;2019年2月18日 下午03时47分16秒&#x2F;&#x2F; 本地化相关的格式。如：ofLocalizedDate()&#x2F;&#x2F; FormatStyle.FULL &#x2F; FormatStyle.LONG &#x2F; FormatStyle.MEDIUM &#x2F; FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 &#x3D; DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM); &#x2F;&#x2F;格式化 String str3 &#x3D; formatter2.format(LocalDate.now()); System.out.println(str3);&#x2F;&#x2F;2019-2-18&#x2F;&#x2F; 重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) DateTimeFormatter formatter3 &#x3D; DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); &#x2F;&#x2F;格式化 String str4 &#x3D; formatter3.format(LocalDateTime.now()); System.out.println(str4);&#x2F;&#x2F;2019-02-18 03:52:09 &#x2F;&#x2F;解析 TemporalAccessor accessor &#x3D; formatter3.parse(&quot;2019-02-18 03:52:09&quot;); System.out.println(accessor); &#125;&#125; java比较器Java实现对象排序的方式有两种：  自然排序： java.lang.Comparable  定制排序： java.util.Comparator 方式一：自然排序： java.lang.ComparableComparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。 如果当前对象this大于形参对象obj， 则返回正整数，如果当前对象this小于形参对象obj， 则返回负整数，如果当前对象this等于形参对象obj， 则返回零。  实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。  对于类 C 的每一个e1和e2来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致。 建议（虽然不是必需的） 最好使自然排序与equals一致。","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"多线程_基础","slug":"多线程_基础","date":"2020-10-19T08:47:52.377Z","updated":"2020-10-28T09:01:08.010Z","comments":true,"path":"2020/10/19/多线程_基础/","link":"","permalink":"https://vankood.github.io/2020/10/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E5%9F%BA%E7%A1%80/","excerpt":"","text":"多线程基本概念程序：是为完成特定任务、某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程：是程序的一次执行过程。或者正在运行的一个程序。是一个动态过程：有他自身产生、存在、消亡的过程。线程：程序内部的一条执行路径。线程是程序执行的一条路径, 一个进程中可以包含多条线程。多线程并发执行可以提高程序的效率, 可以同时完成多项工作。 并行：多个cpu同时执行多个任务。比如多个人做不同的事情。并发：一个cpu（采用时间片）同时执行多个任务。比如：秒杀、多个人同时做一件事情。 守护线程用来服务于用户线程；不需要上层逻辑介入。当线程只剩下守护线程的时候,JVM就会退出；补充一点如果还有其他的任意一个用户线程还在，JVM就不会退出。 java垃圾回收就是一种典型的守护线程。 守护线程是用来服务用户线程的，通过在start()方法前调用 1thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。 用户线程：我们平常创建的普通线程。 线程的创建和使用方式一：继承于Thread类1234567891011121314151617181920212223242526272829303132/** * 多线程的创建，方式一：继承于Thread类 * 1. 创建一个继承于Thread类的子类 * 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 * 3. 创建Thread类的子类的对象 * 4. 通过此对象调用start() * &lt;p&gt; * 例子：遍历100以内的所有的偶数 * * @author vankood */public class Vankood_01 &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread m1=new MyThread(); //4. 通过此对象调用start() m1.start(); for(int i=0;i&lt;10000;i++)&#123; System.out.println(&quot;主线程&quot;); &#125; &#125;&#125;//1. 创建一个继承于Thread类的子类class MyThread extends Thread&#123; //2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中 @Override public void run()&#123; System.out.println(&quot;分线程&quot;); &#125; &#125;&#125; 例子123456789101112131415161718192021222324252627282930313233343536373839/** * 练习：创建两个分线程，其中一个线程遍历100以内的偶数，另一个线程遍历100以内的奇数 * * * @author shkstart * @create 2019-02-13 下午 2:16 */public class vankood_02 &#123; public static void main(String[] args) &#123; Mythread1 m1=new Mythread1(); Mythread2 m2=new Mythread2(); m1.start(); m2.start(); &#125;&#125;class Mythread1 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125;class Mythread2 extends Thread&#123; @Override public void run()&#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125;&#125; 匿名子类方式创建线程1234567891011121314151617181920212223public class vankood_03 &#123; public static void main(String[] args) &#123; new Thread(&quot;线程一&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2==0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); new Thread(&quot;线程二&quot;) &#123; public void run() &#123; for(int i=0;i&lt;100;i++)&#123; if(i%2!=0)&#123; System.out.println(this.getName()+&quot;&quot;+i); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 方式二：实现Runnable接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 创建多线程的方式二：实现Runnable接口 * 1. 创建一个实现了Runnable接口的类 * 2. 实现类去实现Runnable中的抽象方法：run() * 3. 创建实现类的对象 * 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5. 通过Thread类的对象调用start() * * * 比较创建线程的两种方式。 * 开发中：优先选择：实现Runnable接口的方式 * 原因：1. 实现的方式没有类的单继承性的局限性 * 2. 实现的方式更适合来处理多个线程有共享数据的情况。 * * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 * * @author shkstart * @create 2019-02-13 下午 4:34 */class Mythread implements Runnable&#123;// 1. 创建一个实现了Runnable接口的类 @Override public void run() &#123; // 2. 实现类去实现Runnable中的抽象方法：run() for(int i=0;i&lt;100;i++)&#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class vankood_04 &#123; public static void main(String[] args) &#123; Mythread mt=new Mythread(); //3. 创建实现类的对象 Thread t1=new Thread(mt); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.setName(&quot;线程一&quot;); Mythread mt2=new Mythread(); Thread t2=new Thread(mt2); t2.setName(&quot;线程二&quot;); t1.start(); //5. 通过Thread类的对象调用start() t2.start(); &#125;&#125; 方式三：实现Callable接口创建线程的方式三：实现Callable接口。 — JDK 5.0新增 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以有返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 1234567891011121314151617 class NumThread implements Callable&#123; //1.创建一个实现Callable的实现类 @Override //2.实现call方法，将此线程需要执行的操作声明在call()中 public Object call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(i); sum += i; &#125; &#125; return sum; &#125;&#125; 1234567891011121314151617181920public class ThreadNew &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;3.创建Callable接口实现类的对象 NumThread numThread &#x3D; new NumThread(); &#x2F;&#x2F;4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask &#x3D; new FutureTask(numThread); &#x2F;&#x2F;5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start(); try &#123; &#x2F;&#x2F;6.获取Callable中call方法的返回值 &#x2F;&#x2F;get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum &#x3D; futureTask.get(); System.out.println(&quot;总和为：&quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; 方式四：使用线程池 背景： 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路： 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。好处提高响应速度（减少了创建新线程的时间）降低资源消耗（重复利用线程池中线程，不需要每次都创建）便于线程管理corePoolSize：核心池的大小maximumPoolSize：最大线程数keepAliveTime：线程没有任务时最多保持多长时间后会终止 线程池相关API JDK 5.0起提供了线程池相关API： ExecutorService 和 Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task)：执行任务，有返回值，一般又来执行Callable void shutdown() ：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;public class ThreadPool &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性// System.out.println(service.getClass());// service1.setCorePoolSize(15);// service1.setKeepAliveTime(); //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable// service.submit(Callable callable);//适合使用于Callable //3.关闭连接池 service.shutdown(); &#125;&#125; 两种方式的对比比较创建线程的两种方式。 开发中：优先选择：实现Runnable接口的方式** 原因： ** 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况。 联系： public class Thread implements Runnable Thread类实现了Runnable接口。 相同点： 两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 线程的常用方法 测试Thread中的常用方法： start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程1Thread.currentThread().getName() getName():获取当前线程的名字 setName():设置当前线程的名字1HelloThread h1 &#x3D; new HelloThread(&quot;线程一&quot;); yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才 结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级： 1. MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下 被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class HelloThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123;// try &#123;// sleep(10);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i % 20 == 0)&#123;// yield();// &#125; &#125; &#125; public HelloThread(String name)&#123; super(name); &#125;&#125;public class ThreadMethodTest &#123; public static void main(String[] args) &#123; HelloThread h1 = new HelloThread(&quot;Thread：1&quot;);// h1.setName(&quot;线程一&quot;); //设置分线程的优先级 h1.setPriority(Thread.MAX_PRIORITY); h1.start(); //给主线程命名 Thread.currentThread().setName(&quot;主线程&quot;); Thread.currentThread().setPriority(Thread.MIN_PRIORITY); for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + Thread.currentThread().getPriority() + &quot;:&quot; + i); &#125;// if(i == 20)&#123;// try &#123;// h1.join();// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// &#125; &#125;// System.out.println(h1.isAlive()); &#125;&#125; 线程的生命周期线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 *新建**：就是刚使用new方法，new出来的线程； *就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行; *运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能; *阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态; *死亡**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;线程的同步在Java中，我们通过同步机制，来解决线程的安全问题。 方式一：同步代码块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 synchronized(同步监视器)&#123; //需要被同步的代码 &#125; ``` 说明： 1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。要求：多个线程必须要共用同一把锁。补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。### 方式二：同步方法。如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 5.同步的方式，解决了线程的安全问题。---好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 #### 实现Runnable接口的线程同步（同步代码块） ```java class Window1 implements Runnable&#123; private int ticket = 100; // Object obj = new Object(); // Dog dog = new Dog(); @Override public void run() &#123; // Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; class Dog&#123; &#125; 实现Runnable接口的线程同步（同步方法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:卖票，票号为：&quot; + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步代码块)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 *&#x2F;class Window2 extends Thread&#123; private static int ticket &#x3D; 100; private static Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; &#x2F;&#x2F;正确的&#x2F;&#x2F; synchronized (obj)&#123; synchronized (Window2.class)&#123;&#x2F;&#x2F;Class clazz &#x3D; Window2.class,Window2.class只会加载一次 &#x2F;&#x2F;错误的方式：this代表着t1,t2,t3三个对象&#x2F;&#x2F; synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 &#x3D; new Window2(); Window2 t2 &#x3D; new Window2(); Window2 t3 &#x3D; new Window2(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 继承Thread类的线程同步(同步方法) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java;/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式三：Lock锁 — JDK5.0新增 1.synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.优先使用顺序： Lock 同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Window implements Runnable&#123; private int ticket = 10; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true);//true表示公平锁 @Override public void run() &#123; while(true)&#123; try&#123; //2.调用锁定方法lock() lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;：售票，票号为：&quot; + ticket); ticket--; &#125;else&#123; break; &#125; &#125;finally &#123; //3.调用解锁方法：unlock() lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window w = new Window(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 线程的通信notify和notifyallcom.atguigu.java2;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#x2F;** * 线程通信的例子：使用两个线程打印 1-100。线程1, 线程2 交替打印 * * 涉及到的三个方法： * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。 * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 * * 说明： * 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。 * 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。 * 否则，会出现IllegalMonitorStateException异常 * 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() * 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 * 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 * * @author shkstart * @create 2019-02-15 下午 4:21 *&#x2F;class Number implements Runnable&#123; private int number &#x3D; 1; private Object obj &#x3D; new Object(); @Override public void run() &#123; while(true)&#123; synchronized (obj) &#123; obj.notify(); if(number &lt;&#x3D; 100)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; &#x2F;&#x2F;使得调用如下wait()方法的线程进入阻塞状态 obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class CommunicationTest &#123; public static void main(String[] args) &#123; Number number &#x3D; new Number(); Thread t1 &#x3D; new Thread(number); Thread t2 &#x3D; new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; notifyAlljdk5.0新增线程创建方式","categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://vankood.github.io/categories/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://vankood.github.io/categories/JavaWeb/"},{"name":"数据结构","slug":"数据结构","permalink":"https://vankood.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java_web","slug":"Java-web","permalink":"https://vankood.github.io/categories/Java-web/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://vankood.github.io/tags/JAVA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://vankood.github.io/tags/LeetCode/"},{"name":"JVM","slug":"JVM","permalink":"https://vankood.github.io/tags/JVM/"},{"name":"javaWeb","slug":"javaWeb","permalink":"https://vankood.github.io/tags/javaWeb/"},{"name":"数据结构","slug":"数据结构","permalink":"https://vankood.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://vankood.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"基础","slug":"基础","permalink":"https://vankood.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JAVA_WEB","slug":"JAVA-WEB","permalink":"https://vankood.github.io/tags/JAVA-WEB/"}]}